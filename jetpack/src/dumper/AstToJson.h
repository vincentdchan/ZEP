/* Generated by Ruby Script! */

#pragma once

#include <nlohmann/json.hpp>
#include <vector>
#include <memory>
#include <tsl/ordered_map.h>
#include "Utils.h"

namespace jetpack::dumper {

    template<class Key, class T, class Ignore, class Allocator,
         class Hash = std::hash<Key>, class KeyEqual = std::equal_to<Key>,
         class AllocatorPair = typename std::allocator_traits<Allocator>::template rebind_alloc<std::pair<Key, T>>,
         class ValueTypeContainer = std::vector<std::pair<Key, T>, AllocatorPair>>
    using ordered_map = tsl::ordered_map<Key, T, Hash, KeyEqual, AllocatorPair, ValueTypeContainer>;

    using json = nlohmann::basic_json<ordered_map>;

    template <typename T>
    using Sp = std::shared_ptr<T>;

    class AstToJson {
    public:

        static void DumpBaseInfo(json& result, const Sp<SyntaxNode>& node) {
            result["start"] = node->range.first;
            result["end"] = node->range.second;

            json loc = json::object();

            json start = json::object();
            start["line"] = node->location.start.line;
            start["column"] = node->location.start.column;
            loc["start"] = start;

            json end = json::object();
            end["line"] = node->location.end.line;
            end["column"] = node->location.end.column;
            loc["end"] = end;

            result["loc"] = loc;
        }

        static json Dump(const Sp<SyntaxNode>& node) {
            switch (node->type) {

                case SyntaxNodeType::ArrayExpression: {
                    auto child = std::dynamic_pointer_cast<ArrayExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ArrayPattern: {
                    auto child = std::dynamic_pointer_cast<ArrayPattern>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ArrowFunctionExpression: {
                    auto child = std::dynamic_pointer_cast<ArrowFunctionExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::AssignmentExpression: {
                    auto child = std::dynamic_pointer_cast<AssignmentExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::AssignmentPattern: {
                    auto child = std::dynamic_pointer_cast<AssignmentPattern>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::AwaitExpression: {
                    auto child = std::dynamic_pointer_cast<AwaitExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::BinaryExpression: {
                    auto child = std::dynamic_pointer_cast<BinaryExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::BlockStatement: {
                    auto child = std::dynamic_pointer_cast<BlockStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::BreakStatement: {
                    auto child = std::dynamic_pointer_cast<BreakStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::CallExpression: {
                    auto child = std::dynamic_pointer_cast<CallExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::CatchClause: {
                    auto child = std::dynamic_pointer_cast<CatchClause>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ClassBody: {
                    auto child = std::dynamic_pointer_cast<ClassBody>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ClassDeclaration: {
                    auto child = std::dynamic_pointer_cast<ClassDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ClassExpression: {
                    auto child = std::dynamic_pointer_cast<ClassExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ConditionalExpression: {
                    auto child = std::dynamic_pointer_cast<ConditionalExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ContinueStatement: {
                    auto child = std::dynamic_pointer_cast<ContinueStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::DebuggerStatement: {
                    auto child = std::dynamic_pointer_cast<DebuggerStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Directive: {
                    auto child = std::dynamic_pointer_cast<Directive>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::DoWhileStatement: {
                    auto child = std::dynamic_pointer_cast<DoWhileStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::EmptyStatement: {
                    auto child = std::dynamic_pointer_cast<EmptyStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ExportAllDeclaration: {
                    auto child = std::dynamic_pointer_cast<ExportAllDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ExportDefaultDeclaration: {
                    auto child = std::dynamic_pointer_cast<ExportDefaultDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ExportNamedDeclaration: {
                    auto child = std::dynamic_pointer_cast<ExportNamedDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ExportSpecifier: {
                    auto child = std::dynamic_pointer_cast<ExportSpecifier>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ExpressionStatement: {
                    auto child = std::dynamic_pointer_cast<ExpressionStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ForInStatement: {
                    auto child = std::dynamic_pointer_cast<ForInStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ForOfStatement: {
                    auto child = std::dynamic_pointer_cast<ForOfStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ForStatement: {
                    auto child = std::dynamic_pointer_cast<ForStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::FunctionDeclaration: {
                    auto child = std::dynamic_pointer_cast<FunctionDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::FunctionExpression: {
                    auto child = std::dynamic_pointer_cast<FunctionExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Identifier: {
                    auto child = std::dynamic_pointer_cast<Identifier>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::IfStatement: {
                    auto child = std::dynamic_pointer_cast<IfStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Import: {
                    auto child = std::dynamic_pointer_cast<Import>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ImportDeclaration: {
                    auto child = std::dynamic_pointer_cast<ImportDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ImportDefaultSpecifier: {
                    auto child = std::dynamic_pointer_cast<ImportDefaultSpecifier>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ImportNamespaceSpecifier: {
                    auto child = std::dynamic_pointer_cast<ImportNamespaceSpecifier>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ImportSpecifier: {
                    auto child = std::dynamic_pointer_cast<ImportSpecifier>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::LabeledStatement: {
                    auto child = std::dynamic_pointer_cast<LabeledStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Literal: {
                    auto child = std::dynamic_pointer_cast<Literal>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::MetaProperty: {
                    auto child = std::dynamic_pointer_cast<MetaProperty>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::MethodDefinition: {
                    auto child = std::dynamic_pointer_cast<MethodDefinition>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Module: {
                    auto child = std::dynamic_pointer_cast<Module>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::NewExpression: {
                    auto child = std::dynamic_pointer_cast<NewExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ObjectExpression: {
                    auto child = std::dynamic_pointer_cast<ObjectExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ObjectPattern: {
                    auto child = std::dynamic_pointer_cast<ObjectPattern>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Property: {
                    auto child = std::dynamic_pointer_cast<Property>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::RegexLiteral: {
                    auto child = std::dynamic_pointer_cast<RegexLiteral>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::RestElement: {
                    auto child = std::dynamic_pointer_cast<RestElement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ReturnStatement: {
                    auto child = std::dynamic_pointer_cast<ReturnStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Script: {
                    auto child = std::dynamic_pointer_cast<Script>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::SequenceExpression: {
                    auto child = std::dynamic_pointer_cast<SequenceExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::SpreadElement: {
                    auto child = std::dynamic_pointer_cast<SpreadElement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::MemberExpression: {
                    auto child = std::dynamic_pointer_cast<MemberExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Super: {
                    auto child = std::dynamic_pointer_cast<Super>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::SwitchCase: {
                    auto child = std::dynamic_pointer_cast<SwitchCase>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::SwitchStatement: {
                    auto child = std::dynamic_pointer_cast<SwitchStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TaggedTemplateExpression: {
                    auto child = std::dynamic_pointer_cast<TaggedTemplateExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TemplateElement: {
                    auto child = std::dynamic_pointer_cast<TemplateElement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TemplateLiteral: {
                    auto child = std::dynamic_pointer_cast<TemplateLiteral>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ThisExpression: {
                    auto child = std::dynamic_pointer_cast<ThisExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ThrowStatement: {
                    auto child = std::dynamic_pointer_cast<ThrowStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TryStatement: {
                    auto child = std::dynamic_pointer_cast<TryStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::UnaryExpression: {
                    auto child = std::dynamic_pointer_cast<UnaryExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::UpdateExpression: {
                    auto child = std::dynamic_pointer_cast<UpdateExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::VariableDeclaration: {
                    auto child = std::dynamic_pointer_cast<VariableDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::VariableDeclarator: {
                    auto child = std::dynamic_pointer_cast<VariableDeclarator>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::WhileStatement: {
                    auto child = std::dynamic_pointer_cast<WhileStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::WithStatement: {
                    auto child = std::dynamic_pointer_cast<WithStatement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::YieldExpression: {
                    auto child = std::dynamic_pointer_cast<YieldExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ArrowParameterPlaceHolder: {
                    auto child = std::dynamic_pointer_cast<ArrowParameterPlaceHolder>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXClosingElement: {
                    auto child = std::dynamic_pointer_cast<JSXClosingElement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXElement: {
                    auto child = std::dynamic_pointer_cast<JSXElement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXEmptyExpression: {
                    auto child = std::dynamic_pointer_cast<JSXEmptyExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXExpressionContainer: {
                    auto child = std::dynamic_pointer_cast<JSXExpressionContainer>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXIdentifier: {
                    auto child = std::dynamic_pointer_cast<JSXIdentifier>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXMemberExpression: {
                    auto child = std::dynamic_pointer_cast<JSXMemberExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXAttribute: {
                    auto child = std::dynamic_pointer_cast<JSXAttribute>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXNamespacedName: {
                    auto child = std::dynamic_pointer_cast<JSXNamespacedName>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXOpeningElement: {
                    auto child = std::dynamic_pointer_cast<JSXOpeningElement>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXSpreadAttribute: {
                    auto child = std::dynamic_pointer_cast<JSXSpreadAttribute>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXText: {
                    auto child = std::dynamic_pointer_cast<JSXText>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSParameterProperty: {
                    auto child = std::dynamic_pointer_cast<TSParameterProperty>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSDeclareFunction: {
                    auto child = std::dynamic_pointer_cast<TSDeclareFunction>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSDeclareMethod: {
                    auto child = std::dynamic_pointer_cast<TSDeclareMethod>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSQualifiedName: {
                    auto child = std::dynamic_pointer_cast<TSQualifiedName>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSCallSignatureDeclaration: {
                    auto child = std::dynamic_pointer_cast<TSCallSignatureDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSConstructSignatureDeclaration: {
                    auto child = std::dynamic_pointer_cast<TSConstructSignatureDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSPropertySignature: {
                    auto child = std::dynamic_pointer_cast<TSPropertySignature>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSMethodSignature: {
                    auto child = std::dynamic_pointer_cast<TSMethodSignature>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSIndexSignature: {
                    auto child = std::dynamic_pointer_cast<TSIndexSignature>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSAnyKeyword: {
                    auto child = std::dynamic_pointer_cast<TSAnyKeyword>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSBooleanKeyword: {
                    auto child = std::dynamic_pointer_cast<TSBooleanKeyword>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSBigIntKeyword: {
                    auto child = std::dynamic_pointer_cast<TSBigIntKeyword>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSNeverKeyword: {
                    auto child = std::dynamic_pointer_cast<TSNeverKeyword>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSNullKeyword: {
                    auto child = std::dynamic_pointer_cast<TSNullKeyword>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSNumberKeyword: {
                    auto child = std::dynamic_pointer_cast<TSNumberKeyword>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSObjectKeyword: {
                    auto child = std::dynamic_pointer_cast<TSObjectKeyword>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSStringKeyword: {
                    auto child = std::dynamic_pointer_cast<TSStringKeyword>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSSymbolKeyword: {
                    auto child = std::dynamic_pointer_cast<TSSymbolKeyword>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSUndefinedKeyword: {
                    auto child = std::dynamic_pointer_cast<TSUndefinedKeyword>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSUnknownKeyword: {
                    auto child = std::dynamic_pointer_cast<TSUnknownKeyword>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSVoidKeyword: {
                    auto child = std::dynamic_pointer_cast<TSVoidKeyword>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSThisType: {
                    auto child = std::dynamic_pointer_cast<TSThisType>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSFunctionType: {
                    auto child = std::dynamic_pointer_cast<TSFunctionType>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSConstructorType: {
                    auto child = std::dynamic_pointer_cast<TSConstructorType>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeReference: {
                    auto child = std::dynamic_pointer_cast<TSTypeReference>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypePredicate: {
                    auto child = std::dynamic_pointer_cast<TSTypePredicate>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeQuery: {
                    auto child = std::dynamic_pointer_cast<TSTypeQuery>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeLiteral: {
                    auto child = std::dynamic_pointer_cast<TSTypeLiteral>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSArrayType: {
                    auto child = std::dynamic_pointer_cast<TSArrayType>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTupleType: {
                    auto child = std::dynamic_pointer_cast<TSTupleType>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSOptionalType: {
                    auto child = std::dynamic_pointer_cast<TSOptionalType>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSRestType: {
                    auto child = std::dynamic_pointer_cast<TSRestType>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSUnionType: {
                    auto child = std::dynamic_pointer_cast<TSUnionType>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSIntersectionType: {
                    auto child = std::dynamic_pointer_cast<TSIntersectionType>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSConditionalType: {
                    auto child = std::dynamic_pointer_cast<TSConditionalType>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSInferType: {
                    auto child = std::dynamic_pointer_cast<TSInferType>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSParenthesizedType: {
                    auto child = std::dynamic_pointer_cast<TSParenthesizedType>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeOperator: {
                    auto child = std::dynamic_pointer_cast<TSTypeOperator>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSIndexedAccessType: {
                    auto child = std::dynamic_pointer_cast<TSIndexedAccessType>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSMappedType: {
                    auto child = std::dynamic_pointer_cast<TSMappedType>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSLiteralType: {
                    auto child = std::dynamic_pointer_cast<TSLiteralType>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSExpressionWithTypeArguments: {
                    auto child = std::dynamic_pointer_cast<TSExpressionWithTypeArguments>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSInterfaceDeclaration: {
                    auto child = std::dynamic_pointer_cast<TSInterfaceDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSInterfaceBody: {
                    auto child = std::dynamic_pointer_cast<TSInterfaceBody>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeAliasDeclaration: {
                    auto child = std::dynamic_pointer_cast<TSTypeAliasDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSAsExpression: {
                    auto child = std::dynamic_pointer_cast<TSAsExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeAssertion: {
                    auto child = std::dynamic_pointer_cast<TSTypeAssertion>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSEnumDeclaration: {
                    auto child = std::dynamic_pointer_cast<TSEnumDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSEnumMember: {
                    auto child = std::dynamic_pointer_cast<TSEnumMember>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSModuleDeclaration: {
                    auto child = std::dynamic_pointer_cast<TSModuleDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSModuleBlock: {
                    auto child = std::dynamic_pointer_cast<TSModuleBlock>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSImportType: {
                    auto child = std::dynamic_pointer_cast<TSImportType>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSImportEqualsDeclaration: {
                    auto child = std::dynamic_pointer_cast<TSImportEqualsDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSExternalModuleReference: {
                    auto child = std::dynamic_pointer_cast<TSExternalModuleReference>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSNonNullExpression: {
                    auto child = std::dynamic_pointer_cast<TSNonNullExpression>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSExportAssignment: {
                    auto child = std::dynamic_pointer_cast<TSExportAssignment>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSNamespaceExportDeclaration: {
                    auto child = std::dynamic_pointer_cast<TSNamespaceExportDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeAnnotation: {
                    auto child = std::dynamic_pointer_cast<TSTypeAnnotation>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeParameterInstantiation: {
                    auto child = std::dynamic_pointer_cast<TSTypeParameterInstantiation>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeParameterDeclaration: {
                    auto child = std::dynamic_pointer_cast<TSTypeParameterDeclaration>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeParameter: {
                    auto child = std::dynamic_pointer_cast<TSTypeParameter>(node);
                    return Dump(child);
                }

                default:
                    return json::object();

            }
        }

        static json Dump(const Sp<ArrayExpression>& node) {
            json result = json::object();
            result["type"] = "ArrayExpression";
            DumpBaseInfo(result, node);
            json array_elements = json::array();

            for (auto& i : node->elements) {
                if (i.has_value()) {
                    array_elements.push_back(Dump(*i));
                } else {
                    array_elements.push_back(nullptr);
                }
            }
            result["elements"] = std::move(array_elements);

            return result;
        }

        static json Dump(const Sp<ArrayPattern>& node) {
            json result = json::object();
            result["type"] = "ArrayPattern";
            DumpBaseInfo(result, node);
            json array_elements = json::array();

            for (auto& i : node->elements) {
                if (i.has_value()) {
                    array_elements.push_back(Dump(*i));
                } else {
                    array_elements.push_back(nullptr);
                }
            }
            result["elements"] = std::move(array_elements);

            return result;
        }

        static json Dump(const Sp<ArrowFunctionExpression>& node) {
            json result = json::object();
            result["type"] = "ArrowFunctionExpression";
            DumpBaseInfo(result, node);
            if (node->id) {
                result["id"] = Dump(*node->id);
            }
            json array_params = json::array();

              for (auto& i : node->params) {
                  array_params.push_back(Dump(i));
              }
            result["params"] = std::move(array_params);
            result["body"] = Dump(node->body);
            result["generator"] = node->generator;
            result["expression"] = node->expression;
            result["async"] = node->async;

            return result;
        }

        static json Dump(const Sp<AssignmentExpression>& node) {
            json result = json::object();
            result["type"] = "AssignmentExpression";
            DumpBaseInfo(result, node);
            result["operator"] = parser_utils::To_UTF8(node->operator_);
            result["left"] = Dump(node->left);
            result["right"] = Dump(node->right);

            return result;
        }

        static json Dump(const Sp<AssignmentPattern>& node) {
            json result = json::object();
            result["type"] = "AssignmentPattern";
            DumpBaseInfo(result, node);
            result["left"] = Dump(node->left);
            result["right"] = Dump(node->right);

            return result;
        }

        static json Dump(const Sp<AwaitExpression>& node) {
            json result = json::object();
            result["type"] = "AwaitExpression";
            DumpBaseInfo(result, node);
            result["argument"] = Dump(node->argument);

            return result;
        }

        static json Dump(const Sp<BinaryExpression>& node) {
            json result = json::object();
            result["type"] = "BinaryExpression";
            DumpBaseInfo(result, node);
            result["operator"] = parser_utils::To_UTF8(node->operator_);
            result["left"] = Dump(node->left);
            result["right"] = Dump(node->right);

            return result;
        }

        static json Dump(const Sp<BlockStatement>& node) {
            json result = json::object();
            result["type"] = "BlockStatement";
            DumpBaseInfo(result, node);
            json array_body = json::array();

              for (auto& i : node->body) {
                  array_body.push_back(Dump(i));
              }
            result["body"] = std::move(array_body);

            return result;
        }

        static json Dump(const Sp<BreakStatement>& node) {
            json result = json::object();
            result["type"] = "BreakStatement";
            DumpBaseInfo(result, node);
            if (node->label) {
                result["label"] = Dump(*node->label);
            }

            return result;
        }

        static json Dump(const Sp<CallExpression>& node) {
            json result = json::object();
            result["type"] = "CallExpression";
            DumpBaseInfo(result, node);
            result["callee"] = Dump(node->callee);
            json array_arguments = json::array();

              for (auto& i : node->arguments) {
                  array_arguments.push_back(Dump(i));
              }
            result["arguments"] = std::move(array_arguments);

            return result;
        }

        static json Dump(const Sp<CatchClause>& node) {
            json result = json::object();
            result["type"] = "CatchClause";
            DumpBaseInfo(result, node);
            result["param"] = Dump(node->param);
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(const Sp<ClassBody>& node) {
            json result = json::object();
            result["type"] = "ClassBody";
            DumpBaseInfo(result, node);
            json array_body = json::array();

              for (auto& i : node->body) {
                  array_body.push_back(Dump(i));
              }
            result["body"] = std::move(array_body);

            return result;
        }

        static json Dump(const Sp<ClassDeclaration>& node) {
            json result = json::object();
            result["type"] = "ClassDeclaration";
            DumpBaseInfo(result, node);
            if (node->id) {
                result["id"] = Dump(*node->id);
            }
            if (node->super_class) {
                result["superClass"] = Dump(*node->super_class);
            }
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(const Sp<ClassExpression>& node) {
            json result = json::object();
            result["type"] = "ClassExpression";
            DumpBaseInfo(result, node);
            if (node->id) {
                result["id"] = Dump(*node->id);
            }
            if (node->super_class) {
                result["superClass"] = Dump(*node->super_class);
            }
            if (node->body) {
                result["body"] = Dump(*node->body);
            }

            return result;
        }

        static json Dump(const Sp<ConditionalExpression>& node) {
            json result = json::object();
            result["type"] = "ConditionalExpression";
            DumpBaseInfo(result, node);
            result["test"] = Dump(node->test);
            result["consequent"] = Dump(node->consequent);
            result["alternate"] = Dump(node->alternate);

            return result;
        }

        static json Dump(const Sp<ContinueStatement>& node) {
            json result = json::object();
            result["type"] = "ContinueStatement";
            DumpBaseInfo(result, node);
            if (node->label) {
                result["label"] = Dump(*node->label);
            }

            return result;
        }

        static json Dump(const Sp<DebuggerStatement>& node) {
            json result = json::object();
            result["type"] = "DebuggerStatement";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<Directive>& node) {
            json result = json::object();
            result["type"] = "Directive";
            DumpBaseInfo(result, node);
            result["expression"] = Dump(node->expression);
            result["directive"] = parser_utils::To_UTF8(node->directive);

            return result;
        }

        static json Dump(const Sp<DoWhileStatement>& node) {
            json result = json::object();
            result["type"] = "DoWhileStatement";
            DumpBaseInfo(result, node);
            result["body"] = Dump(node->body);
            result["test"] = Dump(node->test);

            return result;
        }

        static json Dump(const Sp<EmptyStatement>& node) {
            json result = json::object();
            result["type"] = "EmptyStatement";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<ExportAllDeclaration>& node) {
            json result = json::object();
            result["type"] = "ExportAllDeclaration";
            DumpBaseInfo(result, node);
            result["source"] = Dump(node->source);

            return result;
        }

        static json Dump(const Sp<ExportDefaultDeclaration>& node) {
            json result = json::object();
            result["type"] = "ExportDefaultDeclaration";
            DumpBaseInfo(result, node);
            result["declaration"] = Dump(node->declaration);

            return result;
        }

        static json Dump(const Sp<ExportNamedDeclaration>& node) {
            json result = json::object();
            result["type"] = "ExportNamedDeclaration";
            DumpBaseInfo(result, node);
            if (node->declaration) {
                result["declaration"] = Dump(*node->declaration);
            }
            json array_specifiers = json::array();

              for (auto& i : node->specifiers) {
                  array_specifiers.push_back(Dump(i));
              }
            result["specifiers"] = std::move(array_specifiers);
            if (node->source) {
                result["source"] = Dump(*node->source);
            }

            return result;
        }

        static json Dump(const Sp<ExportSpecifier>& node) {
            json result = json::object();
            result["type"] = "ExportSpecifier";
            DumpBaseInfo(result, node);
            result["exported"] = Dump(node->exported);
            result["local"] = Dump(node->local);

            return result;
        }

        static json Dump(const Sp<ExpressionStatement>& node) {
            json result = json::object();
            result["type"] = "ExpressionStatement";
            DumpBaseInfo(result, node);
            result["expression"] = Dump(node->expression);

            return result;
        }

        static json Dump(const Sp<ForInStatement>& node) {
            json result = json::object();
            result["type"] = "ForInStatement";
            DumpBaseInfo(result, node);
            result["left"] = Dump(node->left);
            result["right"] = Dump(node->right);
            result["body"] = Dump(node->body);
            result["each"] = node->each;

            return result;
        }

        static json Dump(const Sp<ForOfStatement>& node) {
            json result = json::object();
            result["type"] = "ForOfStatement";
            DumpBaseInfo(result, node);
            result["left"] = Dump(node->left);
            result["right"] = Dump(node->right);
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(const Sp<ForStatement>& node) {
            json result = json::object();
            result["type"] = "ForStatement";
            DumpBaseInfo(result, node);
            if (node->init) {
                result["init"] = Dump(*node->init);
            }
            if (node->test) {
                result["test"] = Dump(*node->test);
            }
            if (node->update) {
                result["update"] = Dump(*node->update);
            }
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(const Sp<FunctionDeclaration>& node) {
            json result = json::object();
            result["type"] = "FunctionDeclaration";
            DumpBaseInfo(result, node);
            if (node->id) {
                result["id"] = Dump(*node->id);
            }
            json array_params = json::array();

              for (auto& i : node->params) {
                  array_params.push_back(Dump(i));
              }
            result["params"] = std::move(array_params);
            result["body"] = Dump(node->body);
            result["generator"] = node->generator;
            result["expression"] = node->expression;
            result["async"] = node->async;

            return result;
        }

        static json Dump(const Sp<FunctionExpression>& node) {
            json result = json::object();
            result["type"] = "FunctionExpression";
            DumpBaseInfo(result, node);
            if (node->id) {
                result["id"] = Dump(*node->id);
            }
            json array_params = json::array();

              for (auto& i : node->params) {
                  array_params.push_back(Dump(i));
              }
            result["params"] = std::move(array_params);
            result["body"] = Dump(node->body);
            result["generator"] = node->generator;
            result["expression"] = node->expression;
            result["async"] = node->async;

            return result;
        }

        static json Dump(const Sp<Identifier>& node) {
            json result = json::object();
            result["type"] = "Identifier";
            DumpBaseInfo(result, node);
            result["name"] = parser_utils::To_UTF8(node->name);

            return result;
        }

        static json Dump(const Sp<IfStatement>& node) {
            json result = json::object();
            result["type"] = "IfStatement";
            DumpBaseInfo(result, node);
            result["test"] = Dump(node->test);
            result["consequent"] = Dump(node->consequent);
            if (node->alternate) {
                result["alternate"] = Dump(*node->alternate);
            }

            return result;
        }

        static json Dump(const Sp<Import>& node) {
            json result = json::object();
            result["type"] = "Import";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<ImportDeclaration>& node) {
            json result = json::object();
            result["type"] = "ImportDeclaration";
            DumpBaseInfo(result, node);
            json array_specifiers = json::array();

              for (auto& i : node->specifiers) {
                  array_specifiers.push_back(Dump(i));
              }
            result["specifiers"] = std::move(array_specifiers);
            result["source"] = Dump(node->source);

            return result;
        }

        static json Dump(const Sp<ImportDefaultSpecifier>& node) {
            json result = json::object();
            result["type"] = "ImportDefaultSpecifier";
            DumpBaseInfo(result, node);
            result["local"] = Dump(node->local);

            return result;
        }

        static json Dump(const Sp<ImportNamespaceSpecifier>& node) {
            json result = json::object();
            result["type"] = "ImportNamespaceSpecifier";
            DumpBaseInfo(result, node);
            result["local"] = Dump(node->local);

            return result;
        }

        static json Dump(const Sp<ImportSpecifier>& node) {
            json result = json::object();
            result["type"] = "ImportSpecifier";
            DumpBaseInfo(result, node);
            result["local"] = Dump(node->local);
            result["imported"] = Dump(node->imported);

            return result;
        }

        static json Dump(const Sp<LabeledStatement>& node) {
            json result = json::object();
            result["type"] = "LabeledStatement";
            DumpBaseInfo(result, node);
            result["label"] = Dump(node->label);
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(const Sp<Literal>& node) {
            json result = json::object();
            result["type"] = "Literal";
            DumpBaseInfo(result, node);
            if (std::holds_alternative<bool>(node->value)) result["value"] = std::get<bool>(node->value);
            if (std::holds_alternative<double>(node->value)) result["value"] = std::get<double>(node->value);
            if (std::holds_alternative<UString>(node->value)) result["value"] = parser_utils::To_UTF8(std::get<UString>(node->value));
            result["raw"] = parser_utils::To_UTF8(node->raw);

            return result;
        }

        static json Dump(const Sp<MetaProperty>& node) {
            json result = json::object();
            result["type"] = "MetaProperty";
            DumpBaseInfo(result, node);
            result["meta"] = Dump(node->meta);
            result["property"] = Dump(node->property);

            return result;
        }

        static json Dump(const Sp<MethodDefinition>& node) {
            json result = json::object();
            result["type"] = "MethodDefinition";
            DumpBaseInfo(result, node);
            if (node->key) {
                result["key"] = Dump(*node->key);
            }
            result["computed"] = node->computed;
            if (node->value) {
                result["value"] = Dump(*node->value);
            }
            result["kind"] = node->kind;
            result["static"] = node->static_;

            return result;
        }

        static json Dump(const Sp<Module>& node) {
            json result = json::object();
            result["type"] = "Module";
            DumpBaseInfo(result, node);
            json array_body = json::array();

              for (auto& i : node->body) {
                  array_body.push_back(Dump(i));
              }
            result["body"] = std::move(array_body);
            result["sourceType"] = parser_utils::To_UTF8(node->source_type);
            json array_comments = json::array();
            result["comments"] = std::move(array_comments);

            return result;
        }

        static json Dump(const Sp<NewExpression>& node) {
            json result = json::object();
            result["type"] = "NewExpression";
            DumpBaseInfo(result, node);
            result["callee"] = Dump(node->callee);
            json array_arguments = json::array();

              for (auto& i : node->arguments) {
                  array_arguments.push_back(Dump(i));
              }
            result["arguments"] = std::move(array_arguments);

            return result;
        }

        static json Dump(const Sp<ObjectExpression>& node) {
            json result = json::object();
            result["type"] = "ObjectExpression";
            DumpBaseInfo(result, node);
            json array_properties = json::array();

              for (auto& i : node->properties) {
                  array_properties.push_back(Dump(i));
              }
            result["properties"] = std::move(array_properties);

            return result;
        }

        static json Dump(const Sp<ObjectPattern>& node) {
            json result = json::object();
            result["type"] = "ObjectPattern";
            DumpBaseInfo(result, node);
            json array_properties = json::array();

              for (auto& i : node->properties) {
                  array_properties.push_back(Dump(i));
              }
            result["properties"] = std::move(array_properties);

            return result;
        }

        static json Dump(const Sp<Property>& node) {
            json result = json::object();
            result["type"] = "Property";
            DumpBaseInfo(result, node);
            result["key"] = Dump(node->key);
            result["computed"] = node->computed;
            if (node->value) {
                result["value"] = Dump(*node->value);
            }
            result["kind"] = node->kind;
            result["method"] = node->method;
            result["shorthand"] = node->shorthand;

            return result;
        }

        static json Dump(const Sp<RegexLiteral>& node) {
            json result = json::object();
            result["type"] = "RegexLiteral";
            DumpBaseInfo(result, node);
            result["value"] = parser_utils::To_UTF8(node->value);
            result["raw"] = parser_utils::To_UTF8(node->raw);

            return result;
        }

        static json Dump(const Sp<RestElement>& node) {
            json result = json::object();
            result["type"] = "RestElement";
            DumpBaseInfo(result, node);
            result["argument"] = Dump(node->argument);

            return result;
        }

        static json Dump(const Sp<ReturnStatement>& node) {
            json result = json::object();
            result["type"] = "ReturnStatement";
            DumpBaseInfo(result, node);
            if (node->argument) {
                result["argument"] = Dump(*node->argument);
            }

            return result;
        }

        static json Dump(const Sp<Script>& node) {
            json result = json::object();
            result["type"] = "Script";
            DumpBaseInfo(result, node);
            json array_body = json::array();

              for (auto& i : node->body) {
                  array_body.push_back(Dump(i));
              }
            result["body"] = std::move(array_body);
            result["sourceType"] = parser_utils::To_UTF8(node->source_type);
            json array_comments = json::array();
            result["comments"] = std::move(array_comments);

            return result;
        }

        static json Dump(const Sp<SequenceExpression>& node) {
            json result = json::object();
            result["type"] = "SequenceExpression";
            DumpBaseInfo(result, node);
            json array_expressions = json::array();

              for (auto& i : node->expressions) {
                  array_expressions.push_back(Dump(i));
              }
            result["expressions"] = std::move(array_expressions);

            return result;
        }

        static json Dump(const Sp<SpreadElement>& node) {
            json result = json::object();
            result["type"] = "SpreadElement";
            DumpBaseInfo(result, node);
            result["argument"] = Dump(node->argument);

            return result;
        }

        static json Dump(const Sp<MemberExpression>& node) {
            json result = json::object();
            result["type"] = "MemberExpression";
            DumpBaseInfo(result, node);
            result["computed"] = node->computed;
            result["object"] = Dump(node->object);
            result["property"] = Dump(node->property);

            return result;
        }

        static json Dump(const Sp<Super>& node) {
            json result = json::object();
            result["type"] = "Super";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<SwitchCase>& node) {
            json result = json::object();
            result["type"] = "SwitchCase";
            DumpBaseInfo(result, node);
            if (node->test) {
                result["test"] = Dump(*node->test);
            }
            json array_consequent = json::array();

              for (auto& i : node->consequent) {
                  array_consequent.push_back(Dump(i));
              }
            result["consequent"] = std::move(array_consequent);

            return result;
        }

        static json Dump(const Sp<SwitchStatement>& node) {
            json result = json::object();
            result["type"] = "SwitchStatement";
            DumpBaseInfo(result, node);
            result["discrimiant"] = Dump(node->discrimiant);
            json array_cases = json::array();

              for (auto& i : node->cases) {
                  array_cases.push_back(Dump(i));
              }
            result["cases"] = std::move(array_cases);

            return result;
        }

        static json Dump(const Sp<TaggedTemplateExpression>& node) {
            json result = json::object();
            result["type"] = "TaggedTemplateExpression";
            DumpBaseInfo(result, node);
            result["tag"] = Dump(node->tag);
            result["quasi"] = Dump(node->quasi);

            return result;
        }

        static json Dump(const Sp<TemplateElement>& node) {
            json result = json::object();
            result["type"] = "TemplateElement";
            DumpBaseInfo(result, node);
            result["cooked"] = parser_utils::To_UTF8(node->cooked);
            result["raw"] = parser_utils::To_UTF8(node->raw);
            result["tail"] = node->tail;

            return result;
        }

        static json Dump(const Sp<TemplateLiteral>& node) {
            json result = json::object();
            result["type"] = "TemplateLiteral";
            DumpBaseInfo(result, node);
            json array_quasis = json::array();

              for (auto& i : node->quasis) {
                  array_quasis.push_back(Dump(i));
              }
            result["quasis"] = std::move(array_quasis);
            json array_expressions = json::array();

              for (auto& i : node->expressions) {
                  array_expressions.push_back(Dump(i));
              }
            result["expressions"] = std::move(array_expressions);

            return result;
        }

        static json Dump(const Sp<ThisExpression>& node) {
            json result = json::object();
            result["type"] = "ThisExpression";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<ThrowStatement>& node) {
            json result = json::object();
            result["type"] = "ThrowStatement";
            DumpBaseInfo(result, node);
            result["argument"] = Dump(node->argument);

            return result;
        }

        static json Dump(const Sp<TryStatement>& node) {
            json result = json::object();
            result["type"] = "TryStatement";
            DumpBaseInfo(result, node);
            result["block"] = Dump(node->block);
            if (node->handler) {
                result["handler"] = Dump(*node->handler);
            }
            if (node->finalizer) {
                result["finalizer"] = Dump(*node->finalizer);
            }

            return result;
        }

        static json Dump(const Sp<UnaryExpression>& node) {
            json result = json::object();
            result["type"] = "UnaryExpression";
            DumpBaseInfo(result, node);
            result["operator"] = parser_utils::To_UTF8(node->operator_);
            result["argument"] = Dump(node->argument);
            result["prefix"] = node->prefix;

            return result;
        }

        static json Dump(const Sp<UpdateExpression>& node) {
            json result = json::object();
            result["type"] = "UpdateExpression";
            DumpBaseInfo(result, node);
            result["operator"] = parser_utils::To_UTF8(node->operator_);
            result["argument"] = Dump(node->argument);
            result["prefix"] = node->prefix;

            return result;
        }

        static json Dump(const Sp<VariableDeclaration>& node) {
            json result = json::object();
            result["type"] = "VariableDeclaration";
            DumpBaseInfo(result, node);
            json array_declarations = json::array();

              for (auto& i : node->declarations) {
                  array_declarations.push_back(Dump(i));
              }
            result["declarations"] = std::move(array_declarations);
            result["kind"] = node->kind;

            return result;
        }

        static json Dump(const Sp<VariableDeclarator>& node) {
            json result = json::object();
            result["type"] = "VariableDeclarator";
            DumpBaseInfo(result, node);
            result["id"] = Dump(node->id);
            if (node->init) {
                result["init"] = Dump(*node->init);
            }

            return result;
        }

        static json Dump(const Sp<WhileStatement>& node) {
            json result = json::object();
            result["type"] = "WhileStatement";
            DumpBaseInfo(result, node);
            result["test"] = Dump(node->test);
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(const Sp<WithStatement>& node) {
            json result = json::object();
            result["type"] = "WithStatement";
            DumpBaseInfo(result, node);
            result["object"] = Dump(node->object);
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(const Sp<YieldExpression>& node) {
            json result = json::object();
            result["type"] = "YieldExpression";
            DumpBaseInfo(result, node);
            if (node->argument) {
                result["argument"] = Dump(*node->argument);
            }
            result["delegate"] = node->delegate;

            return result;
        }

        static json Dump(const Sp<ArrowParameterPlaceHolder>& node) {
            json result = json::object();
            result["type"] = "ArrowParameterPlaceHolder";
            DumpBaseInfo(result, node);
            json array_params = json::array();

              for (auto& i : node->params) {
                  array_params.push_back(Dump(i));
              }
            result["params"] = std::move(array_params);
            result["async"] = node->async;

            return result;
        }

        static json Dump(const Sp<JSXClosingElement>& node) {
            json result = json::object();
            result["type"] = "JSXClosingElement";
            DumpBaseInfo(result, node);
            result["name"] = Dump(node->name);

            return result;
        }

        static json Dump(const Sp<JSXElement>& node) {
            json result = json::object();
            result["type"] = "JSXElement";
            DumpBaseInfo(result, node);
            result["openingElement"] = Dump(node->opening_element);
            json array_children = json::array();

              for (auto& i : node->children) {
                  array_children.push_back(Dump(i));
              }
            result["children"] = std::move(array_children);
            if (node->closing_element) {
                result["closingElement"] = Dump(*node->closing_element);
            }

            return result;
        }

        static json Dump(const Sp<JSXEmptyExpression>& node) {
            json result = json::object();
            result["type"] = "JSXEmptyExpression";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<JSXExpressionContainer>& node) {
            json result = json::object();
            result["type"] = "JSXExpressionContainer";
            DumpBaseInfo(result, node);
            result["expression"] = Dump(node->expression);

            return result;
        }

        static json Dump(const Sp<JSXIdentifier>& node) {
            json result = json::object();
            result["type"] = "JSXIdentifier";
            DumpBaseInfo(result, node);
            result["name"] = parser_utils::To_UTF8(node->name);

            return result;
        }

        static json Dump(const Sp<JSXMemberExpression>& node) {
            json result = json::object();
            result["type"] = "JSXMemberExpression";
            DumpBaseInfo(result, node);
            result["object"] = Dump(node->object);
            result["property"] = Dump(node->property);

            return result;
        }

        static json Dump(const Sp<JSXAttribute>& node) {
            json result = json::object();
            result["type"] = "JSXAttribute";
            DumpBaseInfo(result, node);
            result["name"] = Dump(node->name);
            if (node->value) {
                result["value"] = Dump(*node->value);
            }

            return result;
        }

        static json Dump(const Sp<JSXNamespacedName>& node) {
            json result = json::object();
            result["type"] = "JSXNamespacedName";
            DumpBaseInfo(result, node);
            result["namespace_"] = Dump(node->namespace_);
            result["name"] = Dump(node->name);

            return result;
        }

        static json Dump(const Sp<JSXOpeningElement>& node) {
            json result = json::object();
            result["type"] = "JSXOpeningElement";
            DumpBaseInfo(result, node);
            result["name"] = Dump(node->name);
            result["selfClosing"] = node->self_closing;
            json array_attributes = json::array();

              for (auto& i : node->attributes) {
                  array_attributes.push_back(Dump(i));
              }
            result["attributes"] = std::move(array_attributes);

            return result;
        }

        static json Dump(const Sp<JSXSpreadAttribute>& node) {
            json result = json::object();
            result["type"] = "JSXSpreadAttribute";
            DumpBaseInfo(result, node);
            result["argument"] = Dump(node->argument);

            return result;
        }

        static json Dump(const Sp<JSXText>& node) {
            json result = json::object();
            result["type"] = "JSXText";
            DumpBaseInfo(result, node);
            result["value"] = parser_utils::To_UTF8(node->value);
            result["raw"] = parser_utils::To_UTF8(node->raw);

            return result;
        }

        static json Dump(const Sp<TSParameterProperty>& node) {
            json result = json::object();
            result["type"] = "TSParameterProperty";
            DumpBaseInfo(result, node);
            result["readonly_"] = node->readonly_;
            result["parameter"] = Dump(node->parameter);

            return result;
        }

        static json Dump(const Sp<TSDeclareFunction>& node) {
            json result = json::object();
            result["type"] = "TSDeclareFunction";
            DumpBaseInfo(result, node);
            result["id"] = Dump(node->id);
            result["decare"] = node->decare;
            result["returnType"] = Dump(node->return_type);

            return result;
        }

        static json Dump(const Sp<TSDeclareMethod>& node) {
            json result = json::object();
            result["type"] = "TSDeclareMethod";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSQualifiedName>& node) {
            json result = json::object();
            result["type"] = "TSQualifiedName";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSCallSignatureDeclaration>& node) {
            json result = json::object();
            result["type"] = "TSCallSignatureDeclaration";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSConstructSignatureDeclaration>& node) {
            json result = json::object();
            result["type"] = "TSConstructSignatureDeclaration";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSPropertySignature>& node) {
            json result = json::object();
            result["type"] = "TSPropertySignature";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSMethodSignature>& node) {
            json result = json::object();
            result["type"] = "TSMethodSignature";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSIndexSignature>& node) {
            json result = json::object();
            result["type"] = "TSIndexSignature";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSAnyKeyword>& node) {
            json result = json::object();
            result["type"] = "TSAnyKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSBooleanKeyword>& node) {
            json result = json::object();
            result["type"] = "TSBooleanKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSBigIntKeyword>& node) {
            json result = json::object();
            result["type"] = "TSBigIntKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSNeverKeyword>& node) {
            json result = json::object();
            result["type"] = "TSNeverKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSNullKeyword>& node) {
            json result = json::object();
            result["type"] = "TSNullKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSNumberKeyword>& node) {
            json result = json::object();
            result["type"] = "TSNumberKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSObjectKeyword>& node) {
            json result = json::object();
            result["type"] = "TSObjectKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSStringKeyword>& node) {
            json result = json::object();
            result["type"] = "TSStringKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSSymbolKeyword>& node) {
            json result = json::object();
            result["type"] = "TSSymbolKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSUndefinedKeyword>& node) {
            json result = json::object();
            result["type"] = "TSUndefinedKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSUnknownKeyword>& node) {
            json result = json::object();
            result["type"] = "TSUnknownKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSVoidKeyword>& node) {
            json result = json::object();
            result["type"] = "TSVoidKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSThisType>& node) {
            json result = json::object();
            result["type"] = "TSThisType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSFunctionType>& node) {
            json result = json::object();
            result["type"] = "TSFunctionType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSConstructorType>& node) {
            json result = json::object();
            result["type"] = "TSConstructorType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSTypeReference>& node) {
            json result = json::object();
            result["type"] = "TSTypeReference";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSTypePredicate>& node) {
            json result = json::object();
            result["type"] = "TSTypePredicate";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSTypeQuery>& node) {
            json result = json::object();
            result["type"] = "TSTypeQuery";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSTypeLiteral>& node) {
            json result = json::object();
            result["type"] = "TSTypeLiteral";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSArrayType>& node) {
            json result = json::object();
            result["type"] = "TSArrayType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSTupleType>& node) {
            json result = json::object();
            result["type"] = "TSTupleType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSOptionalType>& node) {
            json result = json::object();
            result["type"] = "TSOptionalType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSRestType>& node) {
            json result = json::object();
            result["type"] = "TSRestType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSUnionType>& node) {
            json result = json::object();
            result["type"] = "TSUnionType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSIntersectionType>& node) {
            json result = json::object();
            result["type"] = "TSIntersectionType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSConditionalType>& node) {
            json result = json::object();
            result["type"] = "TSConditionalType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSInferType>& node) {
            json result = json::object();
            result["type"] = "TSInferType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSParenthesizedType>& node) {
            json result = json::object();
            result["type"] = "TSParenthesizedType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSTypeOperator>& node) {
            json result = json::object();
            result["type"] = "TSTypeOperator";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSIndexedAccessType>& node) {
            json result = json::object();
            result["type"] = "TSIndexedAccessType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSMappedType>& node) {
            json result = json::object();
            result["type"] = "TSMappedType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSLiteralType>& node) {
            json result = json::object();
            result["type"] = "TSLiteralType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSExpressionWithTypeArguments>& node) {
            json result = json::object();
            result["type"] = "TSExpressionWithTypeArguments";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSInterfaceDeclaration>& node) {
            json result = json::object();
            result["type"] = "TSInterfaceDeclaration";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSInterfaceBody>& node) {
            json result = json::object();
            result["type"] = "TSInterfaceBody";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSTypeAliasDeclaration>& node) {
            json result = json::object();
            result["type"] = "TSTypeAliasDeclaration";
            DumpBaseInfo(result, node);
            result["id"] = Dump(node->id);
            if (node->type_parameters) {
                result["typeParameters"] = Dump(*node->type_parameters);
            }
            result["typeAnnotation"] = Dump(node->type_annotation);

            return result;
        }

        static json Dump(const Sp<TSAsExpression>& node) {
            json result = json::object();
            result["type"] = "TSAsExpression";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSTypeAssertion>& node) {
            json result = json::object();
            result["type"] = "TSTypeAssertion";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSEnumDeclaration>& node) {
            json result = json::object();
            result["type"] = "TSEnumDeclaration";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSEnumMember>& node) {
            json result = json::object();
            result["type"] = "TSEnumMember";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSModuleDeclaration>& node) {
            json result = json::object();
            result["type"] = "TSModuleDeclaration";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSModuleBlock>& node) {
            json result = json::object();
            result["type"] = "TSModuleBlock";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSImportType>& node) {
            json result = json::object();
            result["type"] = "TSImportType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSImportEqualsDeclaration>& node) {
            json result = json::object();
            result["type"] = "TSImportEqualsDeclaration";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSExternalModuleReference>& node) {
            json result = json::object();
            result["type"] = "TSExternalModuleReference";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSNonNullExpression>& node) {
            json result = json::object();
            result["type"] = "TSNonNullExpression";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSExportAssignment>& node) {
            json result = json::object();
            result["type"] = "TSExportAssignment";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSNamespaceExportDeclaration>& node) {
            json result = json::object();
            result["type"] = "TSNamespaceExportDeclaration";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSTypeAnnotation>& node) {
            json result = json::object();
            result["type"] = "TSTypeAnnotation";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSTypeParameterInstantiation>& node) {
            json result = json::object();
            result["type"] = "TSTypeParameterInstantiation";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSTypeParameterDeclaration>& node) {
            json result = json::object();
            result["type"] = "TSTypeParameterDeclaration";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(const Sp<TSTypeParameter>& node) {
            json result = json::object();
            result["type"] = "TSTypeParameter";
            DumpBaseInfo(result, node);

            return result;
        }

    };
}
