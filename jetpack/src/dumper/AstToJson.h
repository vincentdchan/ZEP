/* Generated by Ruby Script! */

#pragma once

#include <nlohmann/json.hpp>
#include <vector>
#include <memory>
#include <tsl/ordered_map.h>
#include "utils/Common.h"

namespace jetpack::dumper {

    template<class Key, class T, class Ignore, class Allocator,
         class Hash = std::hash<Key>, class KeyEqual = std::equal_to<Key>,
         class AllocatorPair = typename std::allocator_traits<Allocator>::template rebind_alloc<std::pair<Key, T>>,
         class ValueTypeContainer = std::vector<std::pair<Key, T>, AllocatorPair>>
    using ordered_map = tsl::ordered_map<Key, T, Hash, KeyEqual, AllocatorPair, ValueTypeContainer>;

    using json = nlohmann::basic_json<ordered_map>;

    template <typename T>
    using Sp = std::shared_ptr<T>;

    class AstToJson {
    public:

        static void DumpBaseInfo(json& result, SyntaxNode* node) {
            result["start"] = node->range.first;
            result["end"] = node->range.second;

            json loc = json::object();

            json start = json::object();
            start["line"] = node->location.start.line;
            start["column"] = node->location.start.column;
            loc["start"] = start;

            json end = json::object();
            end["line"] = node->location.end.line;
            end["column"] = node->location.end.column;
            loc["end"] = end;

            result["loc"] = loc;
        }

        static json Dump(SyntaxNode* node) {
            switch (node->type) {

                case SyntaxNodeType::ArrayExpression: {
                    auto child = dynamic_cast<ArrayExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ArrayPattern: {
                    auto child = dynamic_cast<ArrayPattern*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ArrowFunctionExpression: {
                    auto child = dynamic_cast<ArrowFunctionExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::AssignmentExpression: {
                    auto child = dynamic_cast<AssignmentExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::AssignmentPattern: {
                    auto child = dynamic_cast<AssignmentPattern*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::AwaitExpression: {
                    auto child = dynamic_cast<AwaitExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::BinaryExpression: {
                    auto child = dynamic_cast<BinaryExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::BlockStatement: {
                    auto child = dynamic_cast<BlockStatement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::BreakStatement: {
                    auto child = dynamic_cast<BreakStatement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::CallExpression: {
                    auto child = dynamic_cast<CallExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::CatchClause: {
                    auto child = dynamic_cast<CatchClause*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ClassBody: {
                    auto child = dynamic_cast<ClassBody*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ClassDeclaration: {
                    auto child = dynamic_cast<ClassDeclaration*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ClassExpression: {
                    auto child = dynamic_cast<ClassExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ConditionalExpression: {
                    auto child = dynamic_cast<ConditionalExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ContinueStatement: {
                    auto child = dynamic_cast<ContinueStatement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::DebuggerStatement: {
                    auto child = dynamic_cast<DebuggerStatement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Directive: {
                    auto child = dynamic_cast<Directive*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::DoWhileStatement: {
                    auto child = dynamic_cast<DoWhileStatement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::EmptyStatement: {
                    auto child = dynamic_cast<EmptyStatement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ExportAllDeclaration: {
                    auto child = dynamic_cast<ExportAllDeclaration*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ExportDefaultDeclaration: {
                    auto child = dynamic_cast<ExportDefaultDeclaration*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ExportNamedDeclaration: {
                    auto child = dynamic_cast<ExportNamedDeclaration*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ExportSpecifier: {
                    auto child = dynamic_cast<ExportSpecifier*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ExpressionStatement: {
                    auto child = dynamic_cast<ExpressionStatement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ForInStatement: {
                    auto child = dynamic_cast<ForInStatement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ForOfStatement: {
                    auto child = dynamic_cast<ForOfStatement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ForStatement: {
                    auto child = dynamic_cast<ForStatement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::FunctionDeclaration: {
                    auto child = dynamic_cast<FunctionDeclaration*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::FunctionExpression: {
                    auto child = dynamic_cast<FunctionExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Identifier: {
                    auto child = dynamic_cast<Identifier*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::IfStatement: {
                    auto child = dynamic_cast<IfStatement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Import: {
                    auto child = dynamic_cast<Import*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ImportDeclaration: {
                    auto child = dynamic_cast<ImportDeclaration*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ImportDefaultSpecifier: {
                    auto child = dynamic_cast<ImportDefaultSpecifier*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ImportNamespaceSpecifier: {
                    auto child = dynamic_cast<ImportNamespaceSpecifier*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ImportSpecifier: {
                    auto child = dynamic_cast<ImportSpecifier*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::LabeledStatement: {
                    auto child = dynamic_cast<LabeledStatement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Literal: {
                    auto child = dynamic_cast<Literal*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::MetaProperty: {
                    auto child = dynamic_cast<MetaProperty*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::MethodDefinition: {
                    auto child = dynamic_cast<MethodDefinition*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Module: {
                    auto child = dynamic_cast<Module*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::NewExpression: {
                    auto child = dynamic_cast<NewExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ObjectExpression: {
                    auto child = dynamic_cast<ObjectExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ObjectPattern: {
                    auto child = dynamic_cast<ObjectPattern*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Property: {
                    auto child = dynamic_cast<Property*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::RegexLiteral: {
                    auto child = dynamic_cast<RegexLiteral*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::RestElement: {
                    auto child = dynamic_cast<RestElement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ReturnStatement: {
                    auto child = dynamic_cast<ReturnStatement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Script: {
                    auto child = dynamic_cast<Script*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::SequenceExpression: {
                    auto child = dynamic_cast<SequenceExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::SpreadElement: {
                    auto child = dynamic_cast<SpreadElement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::MemberExpression: {
                    auto child = dynamic_cast<MemberExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::Super: {
                    auto child = dynamic_cast<Super*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::SwitchCase: {
                    auto child = dynamic_cast<SwitchCase*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::SwitchStatement: {
                    auto child = dynamic_cast<SwitchStatement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TaggedTemplateExpression: {
                    auto child = dynamic_cast<TaggedTemplateExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TemplateElement: {
                    auto child = dynamic_cast<TemplateElement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TemplateLiteral: {
                    auto child = dynamic_cast<TemplateLiteral*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ThisExpression: {
                    auto child = dynamic_cast<ThisExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ThrowStatement: {
                    auto child = dynamic_cast<ThrowStatement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TryStatement: {
                    auto child = dynamic_cast<TryStatement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::UnaryExpression: {
                    auto child = dynamic_cast<UnaryExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::UpdateExpression: {
                    auto child = dynamic_cast<UpdateExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::VariableDeclaration: {
                    auto child = dynamic_cast<VariableDeclaration*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::VariableDeclarator: {
                    auto child = dynamic_cast<VariableDeclarator*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::WhileStatement: {
                    auto child = dynamic_cast<WhileStatement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::WithStatement: {
                    auto child = dynamic_cast<WithStatement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::YieldExpression: {
                    auto child = dynamic_cast<YieldExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::ArrowParameterPlaceHolder: {
                    auto child = dynamic_cast<ArrowParameterPlaceHolder*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXClosingElement: {
                    auto child = dynamic_cast<JSXClosingElement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXElement: {
                    auto child = dynamic_cast<JSXElement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXEmptyExpression: {
                    auto child = dynamic_cast<JSXEmptyExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXExpressionContainer: {
                    auto child = dynamic_cast<JSXExpressionContainer*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXIdentifier: {
                    auto child = dynamic_cast<JSXIdentifier*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXMemberExpression: {
                    auto child = dynamic_cast<JSXMemberExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXAttribute: {
                    auto child = dynamic_cast<JSXAttribute*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXNamespacedName: {
                    auto child = dynamic_cast<JSXNamespacedName*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXOpeningElement: {
                    auto child = dynamic_cast<JSXOpeningElement*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXSpreadAttribute: {
                    auto child = dynamic_cast<JSXSpreadAttribute*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::JSXText: {
                    auto child = dynamic_cast<JSXText*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSParameterProperty: {
                    auto child = dynamic_cast<TSParameterProperty*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSDeclareFunction: {
                    auto child = dynamic_cast<TSDeclareFunction*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSDeclareMethod: {
                    auto child = dynamic_cast<TSDeclareMethod*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSQualifiedName: {
                    auto child = dynamic_cast<TSQualifiedName*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSCallSignatureDeclaration: {
                    auto child = dynamic_cast<TSCallSignatureDeclaration*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSConstructSignatureDeclaration: {
                    auto child = dynamic_cast<TSConstructSignatureDeclaration*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSPropertySignature: {
                    auto child = dynamic_cast<TSPropertySignature*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSMethodSignature: {
                    auto child = dynamic_cast<TSMethodSignature*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSIndexSignature: {
                    auto child = dynamic_cast<TSIndexSignature*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSAnyKeyword: {
                    auto child = dynamic_cast<TSAnyKeyword*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSBooleanKeyword: {
                    auto child = dynamic_cast<TSBooleanKeyword*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSBigIntKeyword: {
                    auto child = dynamic_cast<TSBigIntKeyword*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSNeverKeyword: {
                    auto child = dynamic_cast<TSNeverKeyword*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSNullKeyword: {
                    auto child = dynamic_cast<TSNullKeyword*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSNumberKeyword: {
                    auto child = dynamic_cast<TSNumberKeyword*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSObjectKeyword: {
                    auto child = dynamic_cast<TSObjectKeyword*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSStringKeyword: {
                    auto child = dynamic_cast<TSStringKeyword*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSSymbolKeyword: {
                    auto child = dynamic_cast<TSSymbolKeyword*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSUndefinedKeyword: {
                    auto child = dynamic_cast<TSUndefinedKeyword*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSUnknownKeyword: {
                    auto child = dynamic_cast<TSUnknownKeyword*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSVoidKeyword: {
                    auto child = dynamic_cast<TSVoidKeyword*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSThisType: {
                    auto child = dynamic_cast<TSThisType*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSFunctionType: {
                    auto child = dynamic_cast<TSFunctionType*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSConstructorType: {
                    auto child = dynamic_cast<TSConstructorType*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeReference: {
                    auto child = dynamic_cast<TSTypeReference*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypePredicate: {
                    auto child = dynamic_cast<TSTypePredicate*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeQuery: {
                    auto child = dynamic_cast<TSTypeQuery*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeLiteral: {
                    auto child = dynamic_cast<TSTypeLiteral*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSArrayType: {
                    auto child = dynamic_cast<TSArrayType*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTupleType: {
                    auto child = dynamic_cast<TSTupleType*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSOptionalType: {
                    auto child = dynamic_cast<TSOptionalType*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSRestType: {
                    auto child = dynamic_cast<TSRestType*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSUnionType: {
                    auto child = dynamic_cast<TSUnionType*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSIntersectionType: {
                    auto child = dynamic_cast<TSIntersectionType*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSConditionalType: {
                    auto child = dynamic_cast<TSConditionalType*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSInferType: {
                    auto child = dynamic_cast<TSInferType*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSParenthesizedType: {
                    auto child = dynamic_cast<TSParenthesizedType*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeOperator: {
                    auto child = dynamic_cast<TSTypeOperator*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSIndexedAccessType: {
                    auto child = dynamic_cast<TSIndexedAccessType*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSMappedType: {
                    auto child = dynamic_cast<TSMappedType*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSLiteralType: {
                    auto child = dynamic_cast<TSLiteralType*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSExpressionWithTypeArguments: {
                    auto child = dynamic_cast<TSExpressionWithTypeArguments*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSInterfaceDeclaration: {
                    auto child = dynamic_cast<TSInterfaceDeclaration*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSInterfaceBody: {
                    auto child = dynamic_cast<TSInterfaceBody*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeAliasDeclaration: {
                    auto child = dynamic_cast<TSTypeAliasDeclaration*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSAsExpression: {
                    auto child = dynamic_cast<TSAsExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeAssertion: {
                    auto child = dynamic_cast<TSTypeAssertion*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSEnumDeclaration: {
                    auto child = dynamic_cast<TSEnumDeclaration*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSEnumMember: {
                    auto child = dynamic_cast<TSEnumMember*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSModuleDeclaration: {
                    auto child = dynamic_cast<TSModuleDeclaration*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSModuleBlock: {
                    auto child = dynamic_cast<TSModuleBlock*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSImportType: {
                    auto child = dynamic_cast<TSImportType*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSImportEqualsDeclaration: {
                    auto child = dynamic_cast<TSImportEqualsDeclaration*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSExternalModuleReference: {
                    auto child = dynamic_cast<TSExternalModuleReference*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSNonNullExpression: {
                    auto child = dynamic_cast<TSNonNullExpression*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSExportAssignment: {
                    auto child = dynamic_cast<TSExportAssignment*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSNamespaceExportDeclaration: {
                    auto child = dynamic_cast<TSNamespaceExportDeclaration*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeAnnotation: {
                    auto child = dynamic_cast<TSTypeAnnotation*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeParameterInstantiation: {
                    auto child = dynamic_cast<TSTypeParameterInstantiation*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeParameterDeclaration: {
                    auto child = dynamic_cast<TSTypeParameterDeclaration*>(node);
                    return Dump(child);
                }

                case SyntaxNodeType::TSTypeParameter: {
                    auto child = dynamic_cast<TSTypeParameter*>(node);
                    return Dump(child);
                }

                default:
                    return json::object();

            }
        }

        static json Dump(ArrayExpression* node) {
            json result = json::object();
            result["type"] = "ArrayExpression";
            DumpBaseInfo(result, node);
            json array_elements = json::array();

            for (auto& i : node->elements) {
                if (i.has_value()) {
                    array_elements.push_back(Dump(*i));
                } else {
                    array_elements.push_back(nullptr);
                }
            }
            result["elements"] = std::move(array_elements);

            return result;
        }

        static json Dump(ArrayPattern* node) {
            json result = json::object();
            result["type"] = "ArrayPattern";
            DumpBaseInfo(result, node);
            json array_elements = json::array();

            for (auto& i : node->elements) {
                if (i.has_value()) {
                    array_elements.push_back(Dump(*i));
                } else {
                    array_elements.push_back(nullptr);
                }
            }
            result["elements"] = std::move(array_elements);

            return result;
        }

        static json Dump(ArrowFunctionExpression* node) {
            json result = json::object();
            result["type"] = "ArrowFunctionExpression";
            DumpBaseInfo(result, node);
            if (node->id) {
                result["id"] = Dump(*node->id);
            }
            json array_params = json::array();

              for (auto& i : node->params) {
                  array_params.push_back(Dump(i));
              }
            result["params"] = std::move(array_params);
            result["body"] = Dump(node->body);
            result["generator"] = node->generator;
            result["expression"] = node->expression;
            result["async"] = node->async;

            return result;
        }

        static json Dump(AssignmentExpression* node) {
            json result = json::object();
            result["type"] = "AssignmentExpression";
            DumpBaseInfo(result, node);
            result["operator"] = node->operator_;
            result["left"] = Dump(node->left);
            result["right"] = Dump(node->right);

            return result;
        }

        static json Dump(AssignmentPattern* node) {
            json result = json::object();
            result["type"] = "AssignmentPattern";
            DumpBaseInfo(result, node);
            result["left"] = Dump(node->left);
            result["right"] = Dump(node->right);

            return result;
        }

        static json Dump(AwaitExpression* node) {
            json result = json::object();
            result["type"] = "AwaitExpression";
            DumpBaseInfo(result, node);
            result["argument"] = Dump(node->argument);

            return result;
        }

        static json Dump(BinaryExpression* node) {
            json result = json::object();
            result["type"] = "BinaryExpression";
            DumpBaseInfo(result, node);
            result["operator"] = node->operator_;
            result["left"] = Dump(node->left);
            result["right"] = Dump(node->right);

            return result;
        }

        static json Dump(BlockStatement* node) {
            json result = json::object();
            result["type"] = "BlockStatement";
            DumpBaseInfo(result, node);
            json array_body = json::array();

              for (auto& i : node->body) {
                  array_body.push_back(Dump(i));
              }
            result["body"] = std::move(array_body);

            return result;
        }

        static json Dump(BreakStatement* node) {
            json result = json::object();
            result["type"] = "BreakStatement";
            DumpBaseInfo(result, node);
            if (node->label) {
                result["label"] = Dump(*node->label);
            }

            return result;
        }

        static json Dump(CallExpression* node) {
            json result = json::object();
            result["type"] = "CallExpression";
            DumpBaseInfo(result, node);
            result["callee"] = Dump(node->callee);
            json array_arguments = json::array();

              for (auto& i : node->arguments) {
                  array_arguments.push_back(Dump(i));
              }
            result["arguments"] = std::move(array_arguments);

            return result;
        }

        static json Dump(CatchClause* node) {
            json result = json::object();
            result["type"] = "CatchClause";
            DumpBaseInfo(result, node);
            result["param"] = Dump(node->param);
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(ClassBody* node) {
            json result = json::object();
            result["type"] = "ClassBody";
            DumpBaseInfo(result, node);
            json array_body = json::array();

              for (auto& i : node->body) {
                  array_body.push_back(Dump(i));
              }
            result["body"] = std::move(array_body);

            return result;
        }

        static json Dump(ClassDeclaration* node) {
            json result = json::object();
            result["type"] = "ClassDeclaration";
            DumpBaseInfo(result, node);
            if (node->id) {
                result["id"] = Dump(*node->id);
            }
            if (node->super_class) {
                result["superClass"] = Dump(*node->super_class);
            }
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(ClassExpression* node) {
            json result = json::object();
            result["type"] = "ClassExpression";
            DumpBaseInfo(result, node);
            if (node->id) {
                result["id"] = Dump(*node->id);
            }
            if (node->super_class) {
                result["superClass"] = Dump(*node->super_class);
            }
            if (node->body) {
                result["body"] = Dump(*node->body);
            }

            return result;
        }

        static json Dump(ConditionalExpression* node) {
            json result = json::object();
            result["type"] = "ConditionalExpression";
            DumpBaseInfo(result, node);
            result["test"] = Dump(node->test);
            result["consequent"] = Dump(node->consequent);
            result["alternate"] = Dump(node->alternate);

            return result;
        }

        static json Dump(ContinueStatement* node) {
            json result = json::object();
            result["type"] = "ContinueStatement";
            DumpBaseInfo(result, node);
            if (node->label) {
                result["label"] = Dump(*node->label);
            }

            return result;
        }

        static json Dump(DebuggerStatement* node) {
            json result = json::object();
            result["type"] = "DebuggerStatement";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(Directive* node) {
            json result = json::object();
            result["type"] = "Directive";
            DumpBaseInfo(result, node);
            result["expression"] = Dump(node->expression);
            result["directive"] = node->directive;

            return result;
        }

        static json Dump(DoWhileStatement* node) {
            json result = json::object();
            result["type"] = "DoWhileStatement";
            DumpBaseInfo(result, node);
            result["body"] = Dump(node->body);
            result["test"] = Dump(node->test);

            return result;
        }

        static json Dump(EmptyStatement* node) {
            json result = json::object();
            result["type"] = "EmptyStatement";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(ExportAllDeclaration* node) {
            json result = json::object();
            result["type"] = "ExportAllDeclaration";
            DumpBaseInfo(result, node);
            result["source"] = Dump(node->source);

            return result;
        }

        static json Dump(ExportDefaultDeclaration* node) {
            json result = json::object();
            result["type"] = "ExportDefaultDeclaration";
            DumpBaseInfo(result, node);
            result["declaration"] = Dump(node->declaration);

            return result;
        }

        static json Dump(ExportNamedDeclaration* node) {
            json result = json::object();
            result["type"] = "ExportNamedDeclaration";
            DumpBaseInfo(result, node);
            if (node->declaration) {
                result["declaration"] = Dump(*node->declaration);
            }
            json array_specifiers = json::array();

              for (auto& i : node->specifiers) {
                  array_specifiers.push_back(Dump(i));
              }
            result["specifiers"] = std::move(array_specifiers);
            if (node->source) {
                result["source"] = Dump(*node->source);
            }

            return result;
        }

        static json Dump(ExportSpecifier* node) {
            json result = json::object();
            result["type"] = "ExportSpecifier";
            DumpBaseInfo(result, node);
            result["exported"] = Dump(node->exported);
            result["local"] = Dump(node->local);

            return result;
        }

        static json Dump(ExpressionStatement* node) {
            json result = json::object();
            result["type"] = "ExpressionStatement";
            DumpBaseInfo(result, node);
            result["expression"] = Dump(node->expression);

            return result;
        }

        static json Dump(ForInStatement* node) {
            json result = json::object();
            result["type"] = "ForInStatement";
            DumpBaseInfo(result, node);
            result["left"] = Dump(node->left);
            result["right"] = Dump(node->right);
            result["body"] = Dump(node->body);
            result["each"] = node->each;

            return result;
        }

        static json Dump(ForOfStatement* node) {
            json result = json::object();
            result["type"] = "ForOfStatement";
            DumpBaseInfo(result, node);
            result["left"] = Dump(node->left);
            result["right"] = Dump(node->right);
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(ForStatement* node) {
            json result = json::object();
            result["type"] = "ForStatement";
            DumpBaseInfo(result, node);
            if (node->init) {
                result["init"] = Dump(*node->init);
            }
            if (node->test) {
                result["test"] = Dump(*node->test);
            }
            if (node->update) {
                result["update"] = Dump(*node->update);
            }
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(FunctionDeclaration* node) {
            json result = json::object();
            result["type"] = "FunctionDeclaration";
            DumpBaseInfo(result, node);
            if (node->id) {
                result["id"] = Dump(*node->id);
            }
            json array_params = json::array();

              for (auto& i : node->params) {
                  array_params.push_back(Dump(i));
              }
            result["params"] = std::move(array_params);
            result["body"] = Dump(node->body);
            result["generator"] = node->generator;
            result["expression"] = node->expression;
            result["async"] = node->async;

            return result;
        }

        static json Dump(FunctionExpression* node) {
            json result = json::object();
            result["type"] = "FunctionExpression";
            DumpBaseInfo(result, node);
            if (node->id) {
                result["id"] = Dump(*node->id);
            }
            json array_params = json::array();

              for (auto& i : node->params) {
                  array_params.push_back(Dump(i));
              }
            result["params"] = std::move(array_params);
            result["body"] = Dump(node->body);
            result["generator"] = node->generator;
            result["expression"] = node->expression;
            result["async"] = node->async;

            return result;
        }

        static json Dump(Identifier* node) {
            json result = json::object();
            result["type"] = "Identifier";
            DumpBaseInfo(result, node);
            result["name"] = node->name;

            return result;
        }

        static json Dump(IfStatement* node) {
            json result = json::object();
            result["type"] = "IfStatement";
            DumpBaseInfo(result, node);
            result["test"] = Dump(node->test);
            result["consequent"] = Dump(node->consequent);
            if (node->alternate) {
                result["alternate"] = Dump(*node->alternate);
            }

            return result;
        }

        static json Dump(Import* node) {
            json result = json::object();
            result["type"] = "Import";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(ImportDeclaration* node) {
            json result = json::object();
            result["type"] = "ImportDeclaration";
            DumpBaseInfo(result, node);
            json array_specifiers = json::array();

              for (auto& i : node->specifiers) {
                  array_specifiers.push_back(Dump(i));
              }
            result["specifiers"] = std::move(array_specifiers);
            result["source"] = Dump(node->source);

            return result;
        }

        static json Dump(ImportDefaultSpecifier* node) {
            json result = json::object();
            result["type"] = "ImportDefaultSpecifier";
            DumpBaseInfo(result, node);
            result["local"] = Dump(node->local);

            return result;
        }

        static json Dump(ImportNamespaceSpecifier* node) {
            json result = json::object();
            result["type"] = "ImportNamespaceSpecifier";
            DumpBaseInfo(result, node);
            result["local"] = Dump(node->local);

            return result;
        }

        static json Dump(ImportSpecifier* node) {
            json result = json::object();
            result["type"] = "ImportSpecifier";
            DumpBaseInfo(result, node);
            result["local"] = Dump(node->local);
            result["imported"] = Dump(node->imported);

            return result;
        }

        static json Dump(LabeledStatement* node) {
            json result = json::object();
            result["type"] = "LabeledStatement";
            DumpBaseInfo(result, node);
            result["label"] = Dump(node->label);
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(Literal* node) {
            json result = json::object();
            result["type"] = "Literal";
            DumpBaseInfo(result, node);

            switch (node->ty) {
                case Literal::Ty::Boolean:
                    result["value"] = node->boolean_;
                    break;

                case Literal::Ty::Double:
                    result["value"] = node->double_;
                    break;

                case Literal::Ty::String:
                    result["value"] = node->str_;
                    break;

                default:
                    break;

            }

            result["raw"] = node->raw;

            return result;
        }

        static json Dump(MetaProperty* node) {
            json result = json::object();
            result["type"] = "MetaProperty";
            DumpBaseInfo(result, node);
            result["meta"] = Dump(node->meta);
            result["property"] = Dump(node->property);

            return result;
        }

        static json Dump(MethodDefinition* node) {
            json result = json::object();
            result["type"] = "MethodDefinition";
            DumpBaseInfo(result, node);
            if (node->key) {
                result["key"] = Dump(*node->key);
            }
            result["computed"] = node->computed;
            if (node->value) {
                result["value"] = Dump(*node->value);
            }
            result["kind"] = node->kind;
            result["static"] = node->static_;

            return result;
        }

        static json Dump(Module* node) {
            json result = json::object();
            result["type"] = "Module";
            DumpBaseInfo(result, node);
            json array_body = json::array();

              for (auto& i : node->body) {
                  array_body.push_back(Dump(i));
              }
            result["body"] = std::move(array_body);
            result["sourceType"] = node->source_type;
            json array_comments = json::array();
            result["comments"] = std::move(array_comments);

            return result;
        }

        static json Dump(NewExpression* node) {
            json result = json::object();
            result["type"] = "NewExpression";
            DumpBaseInfo(result, node);
            result["callee"] = Dump(node->callee);
            json array_arguments = json::array();

              for (auto& i : node->arguments) {
                  array_arguments.push_back(Dump(i));
              }
            result["arguments"] = std::move(array_arguments);

            return result;
        }

        static json Dump(ObjectExpression* node) {
            json result = json::object();
            result["type"] = "ObjectExpression";
            DumpBaseInfo(result, node);
            json array_properties = json::array();

              for (auto& i : node->properties) {
                  array_properties.push_back(Dump(i));
              }
            result["properties"] = std::move(array_properties);

            return result;
        }

        static json Dump(ObjectPattern* node) {
            json result = json::object();
            result["type"] = "ObjectPattern";
            DumpBaseInfo(result, node);
            json array_properties = json::array();

              for (auto& i : node->properties) {
                  array_properties.push_back(Dump(i));
              }
            result["properties"] = std::move(array_properties);

            return result;
        }

        static json Dump(Property* node) {
            json result = json::object();
            result["type"] = "Property";
            DumpBaseInfo(result, node);
            result["key"] = Dump(node->key);
            result["computed"] = node->computed;
            if (node->value) {
                result["value"] = Dump(*node->value);
            }
            result["kind"] = node->kind;
            result["method"] = node->method;
            result["shorthand"] = node->shorthand;

            return result;
        }

        static json Dump(RegexLiteral* node) {
            json result = json::object();
            result["type"] = "RegexLiteral";
            DumpBaseInfo(result, node);
            result["value"] = node->value;
            result["raw"] = node->raw;

            return result;
        }

        static json Dump(RestElement* node) {
            json result = json::object();
            result["type"] = "RestElement";
            DumpBaseInfo(result, node);
            result["argument"] = Dump(node->argument);

            return result;
        }

        static json Dump(ReturnStatement* node) {
            json result = json::object();
            result["type"] = "ReturnStatement";
            DumpBaseInfo(result, node);
            if (node->argument) {
                result["argument"] = Dump(*node->argument);
            }

            return result;
        }

        static json Dump(Script* node) {
            json result = json::object();
            result["type"] = "Script";
            DumpBaseInfo(result, node);
            json array_body = json::array();

              for (auto& i : node->body) {
                  array_body.push_back(Dump(i));
              }
            result["body"] = std::move(array_body);
            result["sourceType"] = node->source_type;
            json array_comments = json::array();
            result["comments"] = std::move(array_comments);

            return result;
        }

        static json Dump(SequenceExpression* node) {
            json result = json::object();
            result["type"] = "SequenceExpression";
            DumpBaseInfo(result, node);
            json array_expressions = json::array();

              for (auto& i : node->expressions) {
                  array_expressions.push_back(Dump(i));
              }
            result["expressions"] = std::move(array_expressions);

            return result;
        }

        static json Dump(SpreadElement* node) {
            json result = json::object();
            result["type"] = "SpreadElement";
            DumpBaseInfo(result, node);
            result["argument"] = Dump(node->argument);

            return result;
        }

        static json Dump(MemberExpression* node) {
            json result = json::object();
            result["type"] = "MemberExpression";
            DumpBaseInfo(result, node);
            result["computed"] = node->computed;
            result["object"] = Dump(node->object);
            result["property"] = Dump(node->property);

            return result;
        }

        static json Dump(Super* node) {
            json result = json::object();
            result["type"] = "Super";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(SwitchCase* node) {
            json result = json::object();
            result["type"] = "SwitchCase";
            DumpBaseInfo(result, node);
            if (node->test) {
                result["test"] = Dump(*node->test);
            }
            json array_consequent = json::array();

              for (auto& i : node->consequent) {
                  array_consequent.push_back(Dump(i));
              }
            result["consequent"] = std::move(array_consequent);

            return result;
        }

        static json Dump(SwitchStatement* node) {
            json result = json::object();
            result["type"] = "SwitchStatement";
            DumpBaseInfo(result, node);
            result["discrimiant"] = Dump(node->discrimiant);
            json array_cases = json::array();

              for (auto& i : node->cases) {
                  array_cases.push_back(Dump(i));
              }
            result["cases"] = std::move(array_cases);

            return result;
        }

        static json Dump(TaggedTemplateExpression* node) {
            json result = json::object();
            result["type"] = "TaggedTemplateExpression";
            DumpBaseInfo(result, node);
            result["tag"] = Dump(node->tag);
            result["quasi"] = Dump(node->quasi);

            return result;
        }

        static json Dump(TemplateElement* node) {
            json result = json::object();
            result["type"] = "TemplateElement";
            DumpBaseInfo(result, node);
            result["cooked"] = node->cooked;
            result["raw"] = node->raw;
            result["tail"] = node->tail;

            return result;
        }

        static json Dump(TemplateLiteral* node) {
            json result = json::object();
            result["type"] = "TemplateLiteral";
            DumpBaseInfo(result, node);
            json array_quasis = json::array();

              for (auto& i : node->quasis) {
                  array_quasis.push_back(Dump(i));
              }
            result["quasis"] = std::move(array_quasis);
            json array_expressions = json::array();

              for (auto& i : node->expressions) {
                  array_expressions.push_back(Dump(i));
              }
            result["expressions"] = std::move(array_expressions);

            return result;
        }

        static json Dump(ThisExpression* node) {
            json result = json::object();
            result["type"] = "ThisExpression";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(ThrowStatement* node) {
            json result = json::object();
            result["type"] = "ThrowStatement";
            DumpBaseInfo(result, node);
            result["argument"] = Dump(node->argument);

            return result;
        }

        static json Dump(TryStatement* node) {
            json result = json::object();
            result["type"] = "TryStatement";
            DumpBaseInfo(result, node);
            result["block"] = Dump(node->block);
            if (node->handler) {
                result["handler"] = Dump(*node->handler);
            }
            if (node->finalizer) {
                result["finalizer"] = Dump(*node->finalizer);
            }

            return result;
        }

        static json Dump(UnaryExpression* node) {
            json result = json::object();
            result["type"] = "UnaryExpression";
            DumpBaseInfo(result, node);
            result["operator"] = node->operator_;
            result["argument"] = Dump(node->argument);
            result["prefix"] = node->prefix;

            return result;
        }

        static json Dump(UpdateExpression* node) {
            json result = json::object();
            result["type"] = "UpdateExpression";
            DumpBaseInfo(result, node);
            result["operator"] = node->operator_;
            result["argument"] = Dump(node->argument);
            result["prefix"] = node->prefix;

            return result;
        }

        static json Dump(VariableDeclaration* node) {
            json result = json::object();
            result["type"] = "VariableDeclaration";
            DumpBaseInfo(result, node);
            json array_declarations = json::array();

              for (auto& i : node->declarations) {
                  array_declarations.push_back(Dump(i));
              }
            result["declarations"] = std::move(array_declarations);
            result["kind"] = node->kind;

            return result;
        }

        static json Dump(VariableDeclarator* node) {
            json result = json::object();
            result["type"] = "VariableDeclarator";
            DumpBaseInfo(result, node);
            result["id"] = Dump(node->id);
            if (node->init) {
                result["init"] = Dump(*node->init);
            }

            return result;
        }

        static json Dump(WhileStatement* node) {
            json result = json::object();
            result["type"] = "WhileStatement";
            DumpBaseInfo(result, node);
            result["test"] = Dump(node->test);
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(WithStatement* node) {
            json result = json::object();
            result["type"] = "WithStatement";
            DumpBaseInfo(result, node);
            result["object"] = Dump(node->object);
            result["body"] = Dump(node->body);

            return result;
        }

        static json Dump(YieldExpression* node) {
            json result = json::object();
            result["type"] = "YieldExpression";
            DumpBaseInfo(result, node);
            if (node->argument) {
                result["argument"] = Dump(*node->argument);
            }
            result["delegate"] = node->delegate;

            return result;
        }

        static json Dump(ArrowParameterPlaceHolder* node) {
            json result = json::object();
            result["type"] = "ArrowParameterPlaceHolder";
            DumpBaseInfo(result, node);
            json array_params = json::array();

              for (auto& i : node->params) {
                  array_params.push_back(Dump(i));
              }
            result["params"] = std::move(array_params);
            result["async"] = node->async;

            return result;
        }

        static json Dump(JSXClosingElement* node) {
            json result = json::object();
            result["type"] = "JSXClosingElement";
            DumpBaseInfo(result, node);
            result["name"] = Dump(node->name);

            return result;
        }

        static json Dump(JSXElement* node) {
            json result = json::object();
            result["type"] = "JSXElement";
            DumpBaseInfo(result, node);
            result["openingElement"] = Dump(node->opening_element);
            json array_children = json::array();

              for (auto& i : node->children) {
                  array_children.push_back(Dump(i));
              }
            result["children"] = std::move(array_children);
            if (node->closing_element) {
                result["closingElement"] = Dump(*node->closing_element);
            }

            return result;
        }

        static json Dump(JSXEmptyExpression* node) {
            json result = json::object();
            result["type"] = "JSXEmptyExpression";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(JSXExpressionContainer* node) {
            json result = json::object();
            result["type"] = "JSXExpressionContainer";
            DumpBaseInfo(result, node);
            result["expression"] = Dump(node->expression);

            return result;
        }

        static json Dump(JSXIdentifier* node) {
            json result = json::object();
            result["type"] = "JSXIdentifier";
            DumpBaseInfo(result, node);
            result["name"] = node->name;

            return result;
        }

        static json Dump(JSXMemberExpression* node) {
            json result = json::object();
            result["type"] = "JSXMemberExpression";
            DumpBaseInfo(result, node);
            result["object"] = Dump(node->object);
            result["property"] = Dump(node->property);

            return result;
        }

        static json Dump(JSXAttribute* node) {
            json result = json::object();
            result["type"] = "JSXAttribute";
            DumpBaseInfo(result, node);
            result["name"] = Dump(node->name);
            if (node->value) {
                result["value"] = Dump(*node->value);
            }

            return result;
        }

        static json Dump(JSXNamespacedName* node) {
            json result = json::object();
            result["type"] = "JSXNamespacedName";
            DumpBaseInfo(result, node);
            result["namespace_"] = Dump(node->namespace_);
            result["name"] = Dump(node->name);

            return result;
        }

        static json Dump(JSXOpeningElement* node) {
            json result = json::object();
            result["type"] = "JSXOpeningElement";
            DumpBaseInfo(result, node);
            result["name"] = Dump(node->name);
            result["selfClosing"] = node->self_closing;
            json array_attributes = json::array();

              for (auto& i : node->attributes) {
                  array_attributes.push_back(Dump(i));
              }
            result["attributes"] = std::move(array_attributes);

            return result;
        }

        static json Dump(JSXSpreadAttribute* node) {
            json result = json::object();
            result["type"] = "JSXSpreadAttribute";
            DumpBaseInfo(result, node);
            result["argument"] = Dump(node->argument);

            return result;
        }

        static json Dump(JSXText* node) {
            json result = json::object();
            result["type"] = "JSXText";
            DumpBaseInfo(result, node);
            result["value"] = node->value;
            result["raw"] = node->raw;

            return result;
        }

        static json Dump(TSParameterProperty* node) {
            json result = json::object();
            result["type"] = "TSParameterProperty";
            DumpBaseInfo(result, node);
            result["readonly_"] = node->readonly_;
            result["parameter"] = Dump(node->parameter);

            return result;
        }

        static json Dump(TSDeclareFunction* node) {
            json result = json::object();
            result["type"] = "TSDeclareFunction";
            DumpBaseInfo(result, node);
            result["id"] = Dump(node->id);
            result["decare"] = node->decare;
            result["returnType"] = Dump(node->return_type);

            return result;
        }

        static json Dump(TSDeclareMethod* node) {
            json result = json::object();
            result["type"] = "TSDeclareMethod";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSQualifiedName* node) {
            json result = json::object();
            result["type"] = "TSQualifiedName";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSCallSignatureDeclaration* node) {
            json result = json::object();
            result["type"] = "TSCallSignatureDeclaration";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSConstructSignatureDeclaration* node) {
            json result = json::object();
            result["type"] = "TSConstructSignatureDeclaration";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSPropertySignature* node) {
            json result = json::object();
            result["type"] = "TSPropertySignature";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSMethodSignature* node) {
            json result = json::object();
            result["type"] = "TSMethodSignature";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSIndexSignature* node) {
            json result = json::object();
            result["type"] = "TSIndexSignature";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSAnyKeyword* node) {
            json result = json::object();
            result["type"] = "TSAnyKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSBooleanKeyword* node) {
            json result = json::object();
            result["type"] = "TSBooleanKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSBigIntKeyword* node) {
            json result = json::object();
            result["type"] = "TSBigIntKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSNeverKeyword* node) {
            json result = json::object();
            result["type"] = "TSNeverKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSNullKeyword* node) {
            json result = json::object();
            result["type"] = "TSNullKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSNumberKeyword* node) {
            json result = json::object();
            result["type"] = "TSNumberKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSObjectKeyword* node) {
            json result = json::object();
            result["type"] = "TSObjectKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSStringKeyword* node) {
            json result = json::object();
            result["type"] = "TSStringKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSSymbolKeyword* node) {
            json result = json::object();
            result["type"] = "TSSymbolKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSUndefinedKeyword* node) {
            json result = json::object();
            result["type"] = "TSUndefinedKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSUnknownKeyword* node) {
            json result = json::object();
            result["type"] = "TSUnknownKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSVoidKeyword* node) {
            json result = json::object();
            result["type"] = "TSVoidKeyword";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSThisType* node) {
            json result = json::object();
            result["type"] = "TSThisType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSFunctionType* node) {
            json result = json::object();
            result["type"] = "TSFunctionType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSConstructorType* node) {
            json result = json::object();
            result["type"] = "TSConstructorType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSTypeReference* node) {
            json result = json::object();
            result["type"] = "TSTypeReference";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSTypePredicate* node) {
            json result = json::object();
            result["type"] = "TSTypePredicate";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSTypeQuery* node) {
            json result = json::object();
            result["type"] = "TSTypeQuery";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSTypeLiteral* node) {
            json result = json::object();
            result["type"] = "TSTypeLiteral";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSArrayType* node) {
            json result = json::object();
            result["type"] = "TSArrayType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSTupleType* node) {
            json result = json::object();
            result["type"] = "TSTupleType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSOptionalType* node) {
            json result = json::object();
            result["type"] = "TSOptionalType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSRestType* node) {
            json result = json::object();
            result["type"] = "TSRestType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSUnionType* node) {
            json result = json::object();
            result["type"] = "TSUnionType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSIntersectionType* node) {
            json result = json::object();
            result["type"] = "TSIntersectionType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSConditionalType* node) {
            json result = json::object();
            result["type"] = "TSConditionalType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSInferType* node) {
            json result = json::object();
            result["type"] = "TSInferType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSParenthesizedType* node) {
            json result = json::object();
            result["type"] = "TSParenthesizedType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSTypeOperator* node) {
            json result = json::object();
            result["type"] = "TSTypeOperator";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSIndexedAccessType* node) {
            json result = json::object();
            result["type"] = "TSIndexedAccessType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSMappedType* node) {
            json result = json::object();
            result["type"] = "TSMappedType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSLiteralType* node) {
            json result = json::object();
            result["type"] = "TSLiteralType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSExpressionWithTypeArguments* node) {
            json result = json::object();
            result["type"] = "TSExpressionWithTypeArguments";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSInterfaceDeclaration* node) {
            json result = json::object();
            result["type"] = "TSInterfaceDeclaration";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSInterfaceBody* node) {
            json result = json::object();
            result["type"] = "TSInterfaceBody";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSTypeAliasDeclaration* node) {
            json result = json::object();
            result["type"] = "TSTypeAliasDeclaration";
            DumpBaseInfo(result, node);
            result["id"] = Dump(node->id);
            if (node->type_parameters) {
                result["typeParameters"] = Dump(*node->type_parameters);
            }
            result["typeAnnotation"] = Dump(node->type_annotation);

            return result;
        }

        static json Dump(TSAsExpression* node) {
            json result = json::object();
            result["type"] = "TSAsExpression";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSTypeAssertion* node) {
            json result = json::object();
            result["type"] = "TSTypeAssertion";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSEnumDeclaration* node) {
            json result = json::object();
            result["type"] = "TSEnumDeclaration";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSEnumMember* node) {
            json result = json::object();
            result["type"] = "TSEnumMember";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSModuleDeclaration* node) {
            json result = json::object();
            result["type"] = "TSModuleDeclaration";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSModuleBlock* node) {
            json result = json::object();
            result["type"] = "TSModuleBlock";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSImportType* node) {
            json result = json::object();
            result["type"] = "TSImportType";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSImportEqualsDeclaration* node) {
            json result = json::object();
            result["type"] = "TSImportEqualsDeclaration";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSExternalModuleReference* node) {
            json result = json::object();
            result["type"] = "TSExternalModuleReference";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSNonNullExpression* node) {
            json result = json::object();
            result["type"] = "TSNonNullExpression";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSExportAssignment* node) {
            json result = json::object();
            result["type"] = "TSExportAssignment";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSNamespaceExportDeclaration* node) {
            json result = json::object();
            result["type"] = "TSNamespaceExportDeclaration";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSTypeAnnotation* node) {
            json result = json::object();
            result["type"] = "TSTypeAnnotation";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSTypeParameterInstantiation* node) {
            json result = json::object();
            result["type"] = "TSTypeParameterInstantiation";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSTypeParameterDeclaration* node) {
            json result = json::object();
            result["type"] = "TSTypeParameterDeclaration";
            DumpBaseInfo(result, node);

            return result;
        }

        static json Dump(TSTypeParameter* node) {
            json result = json::object();
            result["type"] = "TSTypeParameter";
            DumpBaseInfo(result, node);

            return result;
        }

    };
}
