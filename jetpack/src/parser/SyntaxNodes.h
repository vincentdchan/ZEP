/* Generated by Ruby Script! */


#pragma once

#include "BaseNodes.h"
#include <memory>
#include <optional>
#include <vector>
#include <variant>
#include "../scope/Scope.h"

namespace jetpack {
    class AstContext;

    class ArrayExpression: public Expression {
    public:
        ArrayExpression();

        std::vector<std::optional<SyntaxNode*>> elements;

    };

    class ArrayPattern: public Pattern {
    public:
        ArrayPattern();

        std::vector<std::optional<SyntaxNode*>> elements;

    };

    class ArrowFunctionExpression: public Expression {
    public:
        ArrowFunctionExpression(std::unique_ptr<Scope> s);

        std::optional<Identifier*> id;
        std::vector<SyntaxNode*> params;
        SyntaxNode* body;
        bool generator = false;
        bool expression = false;
        bool async = false;

        std::unique_ptr<Scope> scope;

        bool IsGenerator() const override { return generator; }
        bool IsAsync() const override { return async; }

    };

    class AssignmentExpression: public Expression {
    public:
        AssignmentExpression();

        std::string operator_;
        Pattern* left;
        Expression* right;

    };

    class AssignmentPattern: public Pattern {
    public:
        AssignmentPattern();

        SyntaxNode* left;
        Expression* right;

    };

    class AwaitExpression: public Expression {
    public:
        AwaitExpression();

        Expression* argument;

    };

    class BinaryExpression: public Expression {
    public:
        BinaryExpression();

        std::string operator_;
        Expression* left;
        Expression* right;

    };

    class BlockStatement: public Statement {
    public:
        BlockStatement();

        std::vector<SyntaxNode*> body;

        std::optional<std::unique_ptr<Scope>> scope;

    };

    class BreakStatement: public Statement {
    public:
        BreakStatement();

        std::optional<Identifier*> label;

    };

    class CallExpression: public Expression {
    public:
        CallExpression();

        Expression* callee;
        std::vector<SyntaxNode*> arguments;

    };

    class CatchClause: public SyntaxNode {
    public:
        CatchClause();

        SyntaxNode* param;
        BlockStatement* body;

        std::unique_ptr<Scope> scope;

    };

    class ClassBody: public SyntaxNode {
    public:
        ClassBody();

        std::vector<MethodDefinition*> body;

    };

    class ClassDeclaration: public Declaration {
    public:
        ClassDeclaration(std::unique_ptr<Scope> s);

        std::optional<Identifier*> id;
        std::optional<Identifier*> super_class;
        ClassBody* body;

        std::unique_ptr<Scope> scope;

    };

    class ClassExpression: public Expression {
    public:
        ClassExpression(std::unique_ptr<Scope> s);

        std::optional<Identifier*> id;
        std::optional<Identifier*> super_class;
        std::optional<ClassBody*> body;

        std::unique_ptr<Scope> scope;

    };

    class ConditionalExpression: public Expression {
    public:
        ConditionalExpression();

        Expression* test;
        Expression* consequent;
        Expression* alternate;

    };

    class ContinueStatement: public Statement {
    public:
        ContinueStatement();

        std::optional<Identifier*> label;

    };

    class DebuggerStatement: public Statement {
    public:
        DebuggerStatement();


    };

    class Directive: public Statement {
    public:
        Directive();

        Expression* expression;
        std::string directive;

    };

    class DoWhileStatement: public Statement {
    public:
        DoWhileStatement();

        Statement* body;
        Expression* test;

    };

    class EmptyStatement: public Statement {
    public:
        EmptyStatement();


    };

    class ExportAllDeclaration: public Declaration {
    public:
        ExportAllDeclaration();

        Literal* source;

    };

    class ExportDefaultDeclaration: public Declaration {
    public:
        ExportDefaultDeclaration();

        SyntaxNode* declaration;

    };

    class ExportNamedDeclaration: public Declaration {
    public:
        ExportNamedDeclaration();

        std::optional<SyntaxNode*> declaration;
        std::vector<ExportSpecifier*> specifiers;
        std::optional<Literal*> source;

    };

    class ExportSpecifier: public SyntaxNode {
    public:
        ExportSpecifier();

        Identifier* exported;
        Identifier* local;

    };

    class ExpressionStatement: public Statement {
    public:
        ExpressionStatement();

        Expression* expression;

    };

    class ForInStatement: public Statement {
    public:
        ForInStatement(std::unique_ptr<Scope> s);

        SyntaxNode* left;
        SyntaxNode* right;
        Statement* body;
        bool each = false;

        std::unique_ptr<Scope> scope;

    };

    class ForOfStatement: public Statement {
    public:
        ForOfStatement(std::unique_ptr<Scope> s);

        SyntaxNode* left;
        SyntaxNode* right;
        Statement* body;

        std::unique_ptr<Scope> scope;

    };

    class ForStatement: public Statement {
    public:
        ForStatement(std::unique_ptr<Scope> s);

        std::optional<SyntaxNode*> init;
        std::optional<SyntaxNode*> test;
        std::optional<SyntaxNode*> update;
        Statement* body;

        std::unique_ptr<Scope> scope;

    };

    class FunctionDeclaration: public Declaration {
    public:
        FunctionDeclaration(std::unique_ptr<Scope> s);

        std::optional<Identifier*> id;
        std::vector<SyntaxNode*> params;
        BlockStatement* body;
        bool generator = false;
        bool expression = false;
        bool async = false;

        std::unique_ptr<Scope> scope;

    };

    class FunctionExpression: public Expression {
    public:
        FunctionExpression();

        std::optional<Identifier*> id;
        std::vector<SyntaxNode*> params;
        BlockStatement* body;
        bool generator = false;
        bool expression = false;
        bool async = false;

        std::unique_ptr<Scope> scope;

        bool IsGenerator() const override { return generator; }
        bool IsAsync() const override { return async; }

    };

    class Identifier: public Expression, public Pattern {
    public:
        Identifier();

        std::string name;

    };

    class IfStatement: public Statement {
    public:
        IfStatement();

        Expression* test;
        Statement* consequent;
        std::optional<Statement*> alternate;

    };

    class Import: public Expression {
    public:
        Import();


    };

    class ImportDeclaration: public Declaration {
    public:
        ImportDeclaration();

        std::vector<SyntaxNode*> specifiers;
        Literal* source;

    };

    class ImportDefaultSpecifier: public SyntaxNode {
    public:
        ImportDefaultSpecifier();

        Identifier* local;

    };

    class ImportNamespaceSpecifier: public SyntaxNode {
    public:
        ImportNamespaceSpecifier();

        Identifier* local;

    };

    class ImportSpecifier: public SyntaxNode {
    public:
        ImportSpecifier();

        Identifier* local;
        Identifier* imported;

    };

    class LabeledStatement: public Statement {
    public:
        LabeledStatement();

        Identifier* label;
        Statement* body;

    };

    class Literal: public Expression {
    public:
        enum class Ty {
            Invalid = 0,
            Boolean,
            Double,
            String,
            Null,
            Regex,
        };

        Literal();

        Ty ty = Ty::Invalid;

        bool boolean_ = false;
        double double_ = 0;
        std::string str_;

        std::string raw;

    };

    class MetaProperty: public Expression {
    public:
        MetaProperty();

        Identifier* meta;
        Identifier* property;

    };

    class MethodDefinition: public SyntaxNode {
    public:
        MethodDefinition();

        std::optional<SyntaxNode*> key;
        bool computed = false;
        std::optional<Expression*> value;
        VarKind kind;
        bool static_ = false;

    };

    class Module: public SyntaxNode {
    public:
        Module(std::unique_ptr<ModuleScope> s);

        std::vector<SyntaxNode*> body;
        std::string source_type;
        std::vector<Sp<Comment>> comments;

        std::unique_ptr<ModuleScope> scope;

    };

    class NewExpression: public Expression {
    public:
        NewExpression();

        Expression* callee;
        std::vector<SyntaxNode*> arguments;

    };

    class ObjectExpression: public Expression {
    public:
        ObjectExpression();

        std::vector<SyntaxNode*> properties;

    };

    class ObjectPattern: public Pattern {
    public:
        ObjectPattern();

        std::vector<SyntaxNode*> properties;

    };

    class Property: public SyntaxNode {
    public:
        Property();

        SyntaxNode* key;
        bool computed = false;
        std::optional<SyntaxNode*> value;
        VarKind kind;
        bool method = false;
        bool shorthand = false;

    };

    class RegexLiteral: public Expression {
    public:
        RegexLiteral();

        std::string value;
        std::string raw;

    };

    class RestElement: public Pattern, public Expression {
    public:
        RestElement();

        SyntaxNode* argument;

    };

    class ReturnStatement: public Statement {
    public:
        ReturnStatement();

        std::optional<Expression*> argument;

    };

    class Script: public SyntaxNode {
    public:
        Script(std::unique_ptr<Scope> s);

        std::vector<SyntaxNode*> body;
        std::string source_type;
        std::vector<Sp<Comment>> comments;

        std::unique_ptr<Scope> scope;

    };

    class SequenceExpression: public Expression {
    public:
        SequenceExpression();

        std::vector<Expression*> expressions;

    };

    class SpreadElement: public SyntaxNode {
    public:
        SpreadElement();

        Expression* argument;

    };

    class MemberExpression: public Expression, public Pattern {
    public:
        MemberExpression();

        bool computed = false;
        Expression* object;
        Expression* property;

        bool IsComputed() const override { return computed; }

    };

    class Super: public Expression {
    public:
        Super();


    };

    class SwitchCase: public SyntaxNode {
    public:
        SwitchCase();

        std::optional<Expression*> test;
        std::vector<Statement*> consequent;

    };

    class SwitchStatement: public Statement {
    public:
        SwitchStatement(std::unique_ptr<Scope> s);

        Expression* discrimiant;
        std::vector<SwitchCase*> cases;

        std::unique_ptr<Scope> scope;

    };

    class TaggedTemplateExpression: public Expression {
    public:
        TaggedTemplateExpression();

        Expression* tag;
        TemplateLiteral* quasi;

    };

    class TemplateElement: public SyntaxNode {
    public:
        TemplateElement();

        std::string cooked;
        std::string raw;
        bool tail = false;

    };

    class TemplateLiteral: public Expression {
    public:
        TemplateLiteral();

        std::vector<TemplateElement*> quasis;
        std::vector<Expression*> expressions;

    };

    class ThisExpression: public Expression {
    public:
        ThisExpression();


    };

    class ThrowStatement: public Statement {
    public:
        ThrowStatement();

        Expression* argument;

    };

    class TryStatement: public Statement {
    public:
        TryStatement();

        BlockStatement* block;
        std::optional<CatchClause*> handler;
        std::optional<BlockStatement*> finalizer;

    };

    class UnaryExpression: public Expression {
    public:
        UnaryExpression();

        std::string operator_;
        Expression* argument;
        bool prefix = false;

    };

    class UpdateExpression: public Expression {
    public:
        UpdateExpression();

        std::string operator_;
        Expression* argument;
        bool prefix = false;

    };

    class VariableDeclaration: public Declaration {
    public:
        VariableDeclaration();

        std::vector<VariableDeclarator*> declarations;
        VarKind kind;

    };

    class VariableDeclarator: public SyntaxNode {
    public:
        VariableDeclarator(std::unique_ptr<Scope> s);

        SyntaxNode* id;
        std::optional<Expression*> init;

        std::unique_ptr<Scope> scope;

    };

    class WhileStatement: public Statement {
    public:
        WhileStatement();

        Expression* test;
        Statement* body;

    };

    class WithStatement: public Statement {
    public:
        WithStatement();

        Expression* object;
        Statement* body;

    };

    class YieldExpression: public Expression {
    public:
        YieldExpression();

        std::optional<Expression*> argument;
        bool delegate = false;

    };

    class ArrowParameterPlaceHolder: public Expression {
    public:
        ArrowParameterPlaceHolder();

        std::vector<SyntaxNode*> params;
        bool async = false;

        bool IsAsync() const override { return async; }

    };

    class JSXClosingElement: public SyntaxNode {
    public:
        JSXClosingElement();

        SyntaxNode* name;

    };

    class JSXElement: public Expression {
    public:
        JSXElement();

        JSXOpeningElement* opening_element;
        std::vector<SyntaxNode*> children;
        std::optional<JSXClosingElement*> closing_element;

    };

    class JSXEmptyExpression: public SyntaxNode {
    public:
        JSXEmptyExpression();


    };

    class JSXExpressionContainer: public SyntaxNode {
    public:
        JSXExpressionContainer();

        Expression* expression;

    };

    class JSXIdentifier: public SyntaxNode {
    public:
        JSXIdentifier();

        std::string name;

    };

    class JSXMemberExpression: public SyntaxNode {
    public:
        JSXMemberExpression();

        SyntaxNode* object;
        JSXIdentifier* property;

    };

    class JSXAttribute: public SyntaxNode {
    public:
        JSXAttribute();

        SyntaxNode* name;
        std::optional<SyntaxNode*> value;

    };

    class JSXNamespacedName: public SyntaxNode {
    public:
        JSXNamespacedName();

        JSXIdentifier* namespace_;
        JSXIdentifier* name;

    };

    class JSXOpeningElement: public SyntaxNode {
    public:
        JSXOpeningElement();

        SyntaxNode* name;
        bool self_closing = false;
        std::vector<SyntaxNode*> attributes;

    };

    class JSXSpreadAttribute: public SyntaxNode {
    public:
        JSXSpreadAttribute();

        Expression* argument;

    };

    class JSXText: public SyntaxNode {
    public:
        JSXText();

        std::string value;
        std::string raw;

    };

    class TSParameterProperty: public SyntaxNode {
    public:
        TSParameterProperty();

        bool readonly_ = false;
        SyntaxNode* parameter;

    };

    class TSDeclareFunction: public Declaration {
    public:
        TSDeclareFunction();

        Identifier* id;
        bool decare = false;
        TSTypeAnnotation* return_type;

    };

    class TSDeclareMethod: public SyntaxNode {
    public:
        TSDeclareMethod();


    };

    class TSQualifiedName: public SyntaxNode {
    public:
        TSQualifiedName();


    };

    class TSCallSignatureDeclaration: public SyntaxNode {
    public:
        TSCallSignatureDeclaration();


    };

    class TSConstructSignatureDeclaration: public SyntaxNode {
    public:
        TSConstructSignatureDeclaration();


    };

    class TSPropertySignature: public SyntaxNode {
    public:
        TSPropertySignature();


    };

    class TSMethodSignature: public SyntaxNode {
    public:
        TSMethodSignature();


    };

    class TSIndexSignature: public SyntaxNode {
    public:
        TSIndexSignature();


    };

    class TSAnyKeyword: public TSType {
    public:
        TSAnyKeyword();


    };

    class TSBooleanKeyword: public TSType {
    public:
        TSBooleanKeyword();


    };

    class TSBigIntKeyword: public TSType {
    public:
        TSBigIntKeyword();


    };

    class TSNeverKeyword: public TSType {
    public:
        TSNeverKeyword();


    };

    class TSNullKeyword: public TSType {
    public:
        TSNullKeyword();


    };

    class TSNumberKeyword: public TSType {
    public:
        TSNumberKeyword();


    };

    class TSObjectKeyword: public TSType {
    public:
        TSObjectKeyword();


    };

    class TSStringKeyword: public TSType {
    public:
        TSStringKeyword();


    };

    class TSSymbolKeyword: public TSType {
    public:
        TSSymbolKeyword();


    };

    class TSUndefinedKeyword: public TSType {
    public:
        TSUndefinedKeyword();


    };

    class TSUnknownKeyword: public TSType {
    public:
        TSUnknownKeyword();


    };

    class TSVoidKeyword: public TSType {
    public:
        TSVoidKeyword();


    };

    class TSThisType: public TSType {
    public:
        TSThisType();


    };

    class TSFunctionType: public TSType {
    public:
        TSFunctionType();


    };

    class TSConstructorType: public TSType {
    public:
        TSConstructorType();


    };

    class TSTypeReference: public TSType {
    public:
        TSTypeReference();


    };

    class TSTypePredicate: public TSType {
    public:
        TSTypePredicate();


    };

    class TSTypeQuery: public TSType {
    public:
        TSTypeQuery();


    };

    class TSTypeLiteral: public TSType {
    public:
        TSTypeLiteral();


    };

    class TSArrayType: public TSType {
    public:
        TSArrayType();


    };

    class TSTupleType: public TSType {
    public:
        TSTupleType();


    };

    class TSOptionalType: public TSType {
    public:
        TSOptionalType();


    };

    class TSRestType: public TSType {
    public:
        TSRestType();


    };

    class TSUnionType: public TSType {
    public:
        TSUnionType();


    };

    class TSIntersectionType: public TSType {
    public:
        TSIntersectionType();


    };

    class TSConditionalType: public TSType {
    public:
        TSConditionalType();


    };

    class TSInferType: public TSType {
    public:
        TSInferType();


    };

    class TSParenthesizedType: public TSType {
    public:
        TSParenthesizedType();


    };

    class TSTypeOperator: public TSType {
    public:
        TSTypeOperator();


    };

    class TSIndexedAccessType: public TSType {
    public:
        TSIndexedAccessType();


    };

    class TSMappedType: public TSType {
    public:
        TSMappedType();


    };

    class TSLiteralType: public TSType {
    public:
        TSLiteralType();


    };

    class TSExpressionWithTypeArguments: public TSType {
    public:
        TSExpressionWithTypeArguments();


    };

    class TSInterfaceDeclaration: public Declaration {
    public:
        TSInterfaceDeclaration();


    };

    class TSInterfaceBody: public SyntaxNode {
    public:
        TSInterfaceBody();


    };

    class TSTypeAliasDeclaration: public Declaration {
    public:
        TSTypeAliasDeclaration();

        Identifier* id;
        std::optional<TSTypeParameterDeclaration*> type_parameters;
        TSType* type_annotation;

    };

    class TSAsExpression: public Expression {
    public:
        TSAsExpression();


    };

    class TSTypeAssertion: public Expression {
    public:
        TSTypeAssertion();


    };

    class TSEnumDeclaration: public Declaration {
    public:
        TSEnumDeclaration();


    };

    class TSEnumMember: public SyntaxNode {
    public:
        TSEnumMember();


    };

    class TSModuleDeclaration: public Declaration {
    public:
        TSModuleDeclaration();


    };

    class TSModuleBlock: public SyntaxNode {
    public:
        TSModuleBlock();


    };

    class TSImportType: public TSType {
    public:
        TSImportType();


    };

    class TSImportEqualsDeclaration: public Declaration {
    public:
        TSImportEqualsDeclaration();


    };

    class TSExternalModuleReference: public SyntaxNode {
    public:
        TSExternalModuleReference();


    };

    class TSNonNullExpression: public Expression {
    public:
        TSNonNullExpression();


    };

    class TSExportAssignment: public Statement {
    public:
        TSExportAssignment();


    };

    class TSNamespaceExportDeclaration: public Statement {
    public:
        TSNamespaceExportDeclaration();


    };

    class TSTypeAnnotation: public SyntaxNode {
    public:
        TSTypeAnnotation();


    };

    class TSTypeParameterInstantiation: public SyntaxNode {
    public:
        TSTypeParameterInstantiation();


    };

    class TSTypeParameterDeclaration: public SyntaxNode {
    public:
        TSTypeParameterDeclaration();


    };

    class TSTypeParameter: public SyntaxNode {
    public:
        TSTypeParameter();


    };

}

